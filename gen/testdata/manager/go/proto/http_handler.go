// Code generated by gs-http-gen compiler. DO NOT EDIT.

package proto

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"mime"
	"net/http"
	"strconv"

	"github.com/lvan100/golib/errutil"
)

// ErrorHandler is the default handler for reporting errors back to the client.
// By default, it responds with an HTTP 500 status and the error message.
var ErrorHandler = func(r *http.Request, w http.ResponseWriter, err error) {
	http.Error(w, err.Error(), http.StatusInternalServerError)
}

var ctxKey int64

// httpReqResp wraps both *http.Request and http.ResponseWriter.
type httpReqResp struct {
	r *http.Request
	w http.ResponseWriter
}

// getHTTPReqResp retrieves the httpReqResp wrapper from context.
func getHTTPReqResp(ctx context.Context) httpReqResp {
	req, _ := ctx.Value(&ctxKey).(httpReqResp)
	return req
}

// setHTTPReqResp stores the http.Request and http.ResponseWriter
// into the context for later retrieval.
func setHTTPReqResp(ctx context.Context, r *http.Request, w http.ResponseWriter) context.Context {
	return context.WithValue(ctx, &ctxKey, httpReqResp{r, w})
}

// GetReq retrieves the *http.Request from context if available.
func GetReq(ctx context.Context) *http.Request {
	return getHTTPReqResp(ctx).r
}

// GetHeader retrieves a specific HTTP request header by key.
func GetHeader(ctx context.Context, key string) string {
	if r := getHTTPReqResp(ctx).r; r != nil {
		return r.Header.Get(key)
	}
	return ""
}

// SetCode sets the HTTP response status code.
func SetCode(ctx context.Context, httpCode int) {
	if w := getHTTPReqResp(ctx).w; w != nil {
		w.WriteHeader(httpCode)
	}
}

// SetHeader sets a response header key/value pair.
func SetHeader(ctx context.Context, key, value string) {
	if w := getHTTPReqResp(ctx).w; w != nil {
		w.Header().Set(key, value)
	}
}

// SetCookie adds a Set-Cookie header to the HTTP response.
func SetCookie(ctx context.Context, cookie *http.Cookie) {
	if cookie != nil {
		if w := getHTTPReqResp(ctx).w; w != nil {
			http.SetCookie(w, cookie)
		}
	}
}

// RequestObject defines the interface that all request types must implement.
type RequestObject interface {
	Bind(*http.Request) error
	Validate() error
}

// shouldParseBody determines whether the incoming HTTP method
// is expected to carry a request body that should be parsed.
func shouldParseBody(method string) bool {
	switch method {
	case http.MethodPost, http.MethodPut, http.MethodPatch:
		return true
	default:
		return false
	}
}

// ReadBody reads the request body into a byte slice.
var ReadBody = func(r *http.Request) ([]byte, error) {
	const maxBodySize = int64(10 << 20) // 10 MB is a lot of text

	oldBody := r.Body
	defer func() { _ = oldBody.Close() }()

	reader := io.LimitReader(oldBody, maxBodySize+1)
	b, err := io.ReadAll(reader)
	if err != nil {
		return nil, errutil.Explain(err, "read body error")
	}
	if int64(len(b)) > maxBodySize {
		return nil, errutil.Explain(nil, "body too large")
	}

	r.Body = io.NopCloser(bytes.NewReader(b))
	return b, nil
}

// decodeBodyInto reads and decodes the request body into `i` based on Content-Type.
// It also restores r.Body so it can be read again later if needed.
func decodeBodyInto(r *http.Request, i RequestObject) error {

	// Read request body
	b, err := ReadBody(r)
	if err != nil {
		return err
	}

	contentType := r.Header.Get("Content-Type")
	mediaType, _, _ := mime.ParseMediaType(contentType)

	var asJSON bool
	switch mediaType {
	case "application/json":
		asJSON = true
	case "application/x-www-form-urlencoded":
		asJSON = false
	default:
		if b = bytes.TrimSpace(b); len(b) > 0 {
			if b[0] == '{' || b[0] == '[' { // Looks like JSON
				asJSON = true
			} else {
				asJSON = false
			}
		}
	}

	if b = bytes.TrimSpace(b); len(b) > 0 {
		if asJSON {
			if err = json.Unmarshal(b, i); err != nil {
				return errutil.Explain(err, "json decode error")
			}
		} else {
			v, ok := i.(interface{ DecodeForm(b []byte) error })
			if !ok {
				return errutil.Explain(nil, "decode form error: not a DecodeForm implementer")
			}
			if err = v.DecodeForm(b); err != nil {
				return errutil.Explain(err, "decode form error")
			}
		}
	}

	return nil
}

// ReadRequest parses the request body based on Content-Type
// and decodes it into the given RequestObject.
func ReadRequest(r *http.Request, i RequestObject) error {

	// Only parse body for methods that typically include a body
	if shouldParseBody(r.Method) {
		if err := decodeBodyInto(r, i); err != nil {
			return err
		}
	}

	// Bind fields
	if err := i.Bind(r); err != nil {
		return errutil.Explain(err, "bind fileds error")
	}

	// Validate fields
	if err := i.Validate(); err != nil {
		return errutil.Explain(err, "validate error")
	}
	return nil
}

type JSONHandler[Req any, Resp any] func(context.Context, Req) Resp

// HandleJSON wraps a JSONHandler into an http.HandlerFunc.
func HandleJSON[Req RequestObject, Resp any](w http.ResponseWriter, r *http.Request,
	req Req, h JSONHandler[Req, Resp]) {

	if err := ReadRequest(r, req); err != nil {
		ErrorHandler(r, w, err)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	ctx := setHTTPReqResp(r.Context(), r, w)
	resp := h(ctx, req)

	if err := json.NewEncoder(w).Encode(resp); err != nil {
		ErrorHandler(r, w, err)
	}
}

// SSEEvent defines the interface that all SSE events must implement.
type ISSEEvent interface {
	HasID() bool
	GetID() string
	HasEvent() bool
	GetEvent() string
	GetData() any
	HasRetry() bool
	GetRetry() int
}

// SSEEvent represents an SSE event.
type SSEEvent[T any] struct {
	id    *string
	event *string
	data  T
	retry *int
}

// NewSSEEvent creates a new SSEEvent.
func NewSSEEvent[T any]() *SSEEvent[T] {
	return &SSEEvent[T]{}
}

// ID sets the ID of the SSE event.
func (e *SSEEvent[T]) ID(id string) *SSEEvent[T] {
	e.id = &id
	return e
}

// Event sets the event type of the SSE event.
func (e *SSEEvent[T]) Event(event string) *SSEEvent[T] {
	e.event = &event
	return e
}

// Data sets the data of the SSE event.
func (e *SSEEvent[T]) Data(data T) *SSEEvent[T] {
	e.data = data
	return e
}

// Retry sets the retry interval of the SSE event.
func (e *SSEEvent[T]) Retry(retry int) *SSEEvent[T] {
	e.retry = &retry
	return e
}

// HasID returns true if the SSE event has an ID.
func (e *SSEEvent[T]) HasID() bool {
	return e.id != nil
}

// GetID returns the ID of the SSE event.
func (e *SSEEvent[T]) GetID() string {
	return *e.id
}

// HasEvent returns true if the SSE event has an event type.
func (e *SSEEvent[T]) HasEvent() bool {
	return e.event != nil
}

// GetEvent returns the event type of the SSE event.
func (e *SSEEvent[T]) GetEvent() string {
	return *e.event
}

func (e *SSEEvent[T]) GetData() any {
	return e.data
}

// HasRetry returns true if the SSE event has a retry interval.
func (e *SSEEvent[T]) HasRetry() bool {
	return e.retry != nil
}

// GetRetry returns the retry interval of the SSE event.
func (e *SSEEvent[T]) GetRetry() int {
	return *e.retry
}

type StreamHandler[Req any, Resp any] func(context.Context, Req, chan<- Resp)

// HandleStream wraps a StreamHandler into an http.HandlerFunc.
// It supports server-sent event style streaming (SSE).
func HandleStream[Req RequestObject, Resp ISSEEvent](w http.ResponseWriter, r *http.Request,
	req Req, h StreamHandler[Req, Resp]) {

	flusher, ok := w.(http.Flusher)
	if !ok {
		err := errutil.Explain(nil, "streaming not supported")
		ErrorHandler(r, w, err)
		return
	}

	if err := ReadRequest(r, req); err != nil {
		ErrorHandler(r, w, err)
		return
	}

	done := make(chan struct{})
	responses := make(chan Resp)
	encoder := json.NewEncoder(w)

	go func() {
		defer close(done)
		for res := range responses {
			select {
			case <-r.Context().Done():
				return
			default: // for linter
			}

			// Write SSE event
			if res.HasID() {
				if _, err := w.Write([]byte("id: " + res.GetID() + "\n")); err != nil {
					ErrorHandler(r, w, err)
					continue
				}
			}

			// Write SSE event
			if res.HasEvent() {
				if _, err := w.Write([]byte("event: " + res.GetEvent() + "\n")); err != nil {
					ErrorHandler(r, w, err)
					continue
				}
			}

			// Write SSE event
			if _, err := w.Write([]byte("data: ")); err != nil {
				ErrorHandler(r, w, err)
				continue
			}
			if err := encoder.Encode(res.GetData()); err != nil {
				ErrorHandler(r, w, err)
				continue
			}
			if _, err := w.Write([]byte("\n")); err != nil {
				ErrorHandler(r, w, err)
				continue
			}

			// Write SSE event
			if res.HasRetry() {
				if _, err := w.Write([]byte("retry: " + strconv.Itoa(res.GetRetry()) + "\n")); err != nil {
					ErrorHandler(r, w, err)
					continue
				}
			}
			flusher.Flush()
		}
	}()

	// Set response headers for SSE
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")

	ctx := setHTTPReqResp(r.Context(), r, w)
	h(ctx, req, responses)
	close(responses)
	<-done
}
