// Code generated by gs-http-gen compiler. DO NOT EDIT.

package proto

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"mime"
	"net/http"
	"net/url"

	"github.com/go-playground/form/v4"
)

// ErrorHandler is the default handler for reporting errors back to the client.
// By default, it responds with an HTTP 500 status and the error message.
var ErrorHandler = func(r *http.Request, w http.ResponseWriter, err error) {
	http.Error(w, err.Error(), http.StatusInternalServerError)
}

const (
	defaultMaxMemory = 32 << 20 // 32 MB
)

var (
	ctxKey int64
)

// httpReqResp wraps both *http.Request and http.ResponseWriter.
type httpReqResp struct {
	r *http.Request
	w http.ResponseWriter
}

// getHTTPReqResp retrieves the httpReqResp wrapper from context.
func getHTTPReqResp(ctx context.Context) httpReqResp {
	req, _ := ctx.Value(&ctxKey).(httpReqResp)
	return req
}

// setHTTPReqResp stores the http.Request and http.ResponseWriter
// into the context for later retrieval.
func setHTTPReqResp(ctx context.Context, r *http.Request, w http.ResponseWriter) context.Context {
	return context.WithValue(ctx, &ctxKey, httpReqResp{r, w})
}

// GetReq retrieves the *http.Request from context if available.
func GetReq(ctx context.Context) *http.Request {
	return getHTTPReqResp(ctx).r
}

// GetHeader retrieves a specific HTTP request header by key.
func GetHeader(ctx context.Context, key string) string {
	if r := getHTTPReqResp(ctx).r; r != nil {
		return r.Header.Get(key)
	}
	return ""
}

// SetHTTPCode sets the HTTP response status code.
func SetHTTPCode(ctx context.Context, httpCode int) {
	if w := getHTTPReqResp(ctx).w; w != nil {
		w.WriteHeader(httpCode)
	}
}

// SetHeader sets a response header key/value pair.
func SetHeader(ctx context.Context, key, value string) {
	if w := getHTTPReqResp(ctx).w; w != nil {
		w.Header().Set(key, value)
	}
}

// SetCookie adds a Set-Cookie header to the HTTP response.
func SetCookie(ctx context.Context, cookie *http.Cookie) {
	if cookie != nil {
		if w := getHTTPReqResp(ctx).w; w != nil {
			http.SetCookie(w, cookie)
		}
	}
}

// BindingField describes a mapping rule for extracting values
// from request headers, path parameters, or query parameters.
type BindingField struct {
	Field  string // Struct field name
	From   string // "header", "path", or "query"
	Name   string // Parameter name
	Target any    // Target struct field pointer
}

var formDecoder = form.NewDecoder()

// Binding applies multiple BindingField rules to extract values
// from a request and bind them into a target object.
func Binding(req *http.Request, params []BindingField) error {
	for _, p := range params {
		if err := bindField(req, p); err != nil {
			return fmt.Errorf("bind field %s error: %w", p.Field, err)
		}
	}
	return nil
}

// bindField extracts a single field value from a request source
// (header, path, or query) and decodes it into the target struct field.
func bindField(req *http.Request, f BindingField) error {
	values := url.Values{}
	switch f.From {
	case "header":
		values[f.Name] = req.Header.Values(f.Name)
	case "path":
		values.Set(f.Name, req.PathValue(f.Name))
	case "query":
		values[f.Name] = req.URL.Query()[f.Name]
	default: // for linter
	}
	return formDecoder.Decode(f.Target, values)
}

// Object defines the interface that all request/response types must implement.
type Object interface {
	New() any                        // Returns a new instance of the object
	Binding(req *http.Request) error // Extracts additional values from the request
	Validate() error                 // Validates object fields
}

// ObjectBase is a base struct for implementing Object.
type ObjectBase struct{}

// New implements the Object interface.
func (x *ObjectBase) New() any {
	return nil
}

// Binding extracts non-body values (header, path, query) from *http.Request.
func (x *ObjectBase) Binding(r *http.Request) error {
	return nil
}

// Validate checks field values using generated validation expressions.
func (x *ObjectBase) Validate() error {
	return nil
}

// ReadRequest parses the request body based on Content-Type
// and decodes it into the given Object.
func ReadRequest(r *http.Request, i Object) error {
	defer func() { _ = r.Body.Close() }()

	contentType := r.Header.Get("Content-Type")
	mediaType, _, _ := mime.ParseMediaType(contentType)

	switch mediaType {
	case "application/json":
		if b, err := io.ReadAll(r.Body); err != nil {
			return fmt.Errorf("read body: %w", err)
		} else if len(b) > 0 {
			if err = json.Unmarshal(b, i); err != nil {
				return fmt.Errorf("json decode: %w", err)
			}
		}

	case "application/x-www-form-urlencoded":
		if err := r.ParseForm(); err != nil {
			return fmt.Errorf("parse form: %w", err)
		}
		if err := formDecoder.Decode(i, r.PostForm); err != nil {
			return fmt.Errorf("form decode: %w", err)
		}

	case "multipart/form-data":
		if err := r.ParseMultipartForm(defaultMaxMemory); err != nil {
			return fmt.Errorf("parse multipart form: %w", err)
		}
		defer func() { _ = r.MultipartForm.RemoveAll() }()
		if r.MultipartForm != nil && len(r.MultipartForm.Value) > 0 {
			if err := formDecoder.Decode(i, r.MultipartForm.Value); err != nil {
				return fmt.Errorf("multipart form decode: %w", err)
			}
		}

	default:
		// Fallback: Try JSON or form decoding
		b, err := io.ReadAll(r.Body)
		if err != nil {
			return fmt.Errorf("read body: %w", err)
		}
		var asJSON bool
		if b = bytes.TrimSpace(b); len(b) > 0 {
			if b[0] == '{' || b[0] == '[' { // Looks like JSON
				if err = json.Unmarshal(b, i); err != nil {
					return fmt.Errorf("json decode: %w", err)
				}
				asJSON = true
			} else {
				r.Body = io.NopCloser(bytes.NewReader(b))
			}
		}
		if !asJSON {
			if err = r.ParseForm(); err != nil {
				return fmt.Errorf("parse form: %w", err)
			}
			if err = formDecoder.Decode(i, r.PostForm); err != nil {
				return fmt.Errorf("form decode: %w", err)
			}
		}
	}

	// Apply bindings
	return i.Binding(r)
}

type JSONHandler[Req, Resp Object] func(context.Context, Req) Resp

// HandleJSON wraps a JSONHandler into an http.HandlerFunc.
func HandleJSON[Req, Resp Object](h JSONHandler[Req, Resp]) http.HandlerFunc {
	var x Req
	return func(w http.ResponseWriter, r *http.Request) {
		req := x.New().(Req)
		if err := ReadRequest(r, req); err != nil {
			ErrorHandler(r, w, err)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		ctx := setHTTPReqResp(r.Context(), r, w)
		resp := h(ctx, req)

		if err := json.NewEncoder(w).Encode(resp); err != nil {
			ErrorHandler(r, w, err)
		}
	}
}

type StreamHandler[Req, Resp Object] func(context.Context, Req, chan<- Resp)

// HandleStream wraps a StreamHandler into an http.HandlerFunc.
// It supports server-sent event style streaming (SSE).
func HandleStream[Req, Resp Object](h StreamHandler[Req, Resp]) http.HandlerFunc {
	var x Req
	return func(w http.ResponseWriter, r *http.Request) {
		flusher, ok := w.(http.Flusher)
		if !ok {
			err := fmt.Errorf("streaming not supported")
			ErrorHandler(r, w, err)
			return
		}

		req := x.New().(Req)
		if err := ReadRequest(r, req); err != nil {
			ErrorHandler(r, w, err)
			return
		}

		done := make(chan struct{})
		responses := make(chan Resp)
		encoder := json.NewEncoder(w)

		go func() {
			defer close(done)
			for res := range responses {
				select {
				case <-r.Context().Done():
					return
				default: // for linter
				}
				if _, err := w.Write([]byte("data:")); err != nil {
					ErrorHandler(r, w, err)
					continue
				}
				if err := encoder.Encode(res); err != nil {
					ErrorHandler(r, w, err)
					continue
				}
				if _, err := w.Write([]byte("\n")); err != nil {
					ErrorHandler(r, w, err)
					continue
				}
				flusher.Flush()
			}
		}()

		// Set response headers for SSE
		w.Header().Set("Content-Type", "text/event-stream")
		w.Header().Set("Cache-Control", "no-cache")
		w.Header().Set("Connection", "keep-alive")

		ctx := setHTTPReqResp(r.Context(), r, w)
		h(ctx, req, responses)
		close(responses)
		<-done
	}
}
