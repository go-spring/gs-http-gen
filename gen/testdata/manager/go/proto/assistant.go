// Code generated by gs-http-gen compiler. DO NOT EDIT.

package proto

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/lvan100/golib/errutil"
)

var _ = json.Marshal
var _ = strings.Contains
var _ = http.NewServeMux
var _ = strconv.FormatInt

type PayloadType int32

const (
	PayloadType_Payload_1 PayloadType = 0
	PayloadType_Payload_2 PayloadType = 1
	PayloadType_Payload_3 PayloadType = 2
)

var (
	PayloadType_name = map[PayloadType]string{
		0: "Payload_1",
		1: "Payload_2",
		2: "Payload_3",
	}
	PayloadType_value = map[string]PayloadType{
		"Payload_1": 0,
		"Payload_2": 1,
		"Payload_3": 2,
	}
)

// OneOfPayloadType is usually used for validation.
func OneOfPayloadType(i PayloadType) bool {
	_, ok := PayloadType_name[i]
	return ok
}

// OneOfPayloadTypeAsString is usually used for validation.
func OneOfPayloadTypeAsString(i PayloadTypeAsString) bool {
	_, ok := PayloadType_name[PayloadType(i)]
	return ok
}

// PayloadTypeAsString wraps PayloadType to encode/decode as a JSON string.
type PayloadTypeAsString PayloadType

// MarshalJSON implements custom JSON encoding for the enum as a string.
func (x PayloadTypeAsString) MarshalJSON() ([]byte, error) {
	if s, ok := PayloadType_name[PayloadType(x)]; ok {
		return []byte(fmt.Sprintf("\"%s\"", s)), nil
	}
	return nil, errutil.Explain(nil, "invalid PayloadType: %d", x)
}

// UnmarshalJSON implements custom JSON decoding for the enum from a string.
func (x *PayloadTypeAsString) UnmarshalJSON(data []byte) error {
	str := strings.Trim(string(data), "\"")
	if v, ok := PayloadType_value[str]; ok {
		*x = PayloadTypeAsString(v)
		return nil
	}
	return errutil.Explain(nil, "invalid PayloadType value: %q", str)
}

type AssistantReq struct {
	AssistantReqBody
}

// QueryForm returns the form values of the object.
func (x *AssistantReq) QueryForm() (string, error) {
	return "", nil
}

// Binding extracts non-body values (path, query) from *http.Request.
func (x *AssistantReq) Bind(r *http.Request) error {
	return nil
}

// Validate checks field values using generated validation expressions.
func (x *AssistantReq) Validate() (err error) {
	if validateErr := x.AssistantReqBody.Validate(); validateErr != nil {
		err = errutil.Stack(err, "validate failed on \"AssistantReq\": %w", validateErr)
	}
	return
}

type AssistantReqBody struct {
	Items []*Item `json:"items,omitempty" form:"items"`
}

// EncodeForm encodes the object to form data.
func (x *AssistantReqBody) EncodeForm() (string, error) {
	m := make(url.Values)
	for i := range len(x.Items) {
		if x.Items[i] != nil {
			b, err := json.Marshal(*x.Items[i])
			if err != nil {
				return "", err
			}
			m.Add("items", string(b))
		}
	}
	return m.Encode(), nil
}

// DecodeForm decodes the object from form data.
func (x *AssistantReqBody) DecodeForm(b []byte) error {
	values, err := url.ParseQuery(string(b))
	if err != nil {
		return errutil.Explain(err, "parse query error")
	}
	if len(values) == 0 {
		return nil
	}
	if v, ok := values["items"]; ok {
		for _, s := range v {
			var i *Item
			parseErr := json.Unmarshal([]byte(s), &i)
			if parseErr != nil {
				err = errutil.Stack(err, "json decode error: %w", parseErr)
			}
			x.Items = append(x.Items, i)
		}
	}
	return err
}

// Validate checks field values using generated validation expressions.
func (x *AssistantReqBody) Validate() (err error) {
	return
}

type Item struct {
	Id *string `json:"id,omitempty" form:"id"`
}

// Validate checks field values using generated validation expressions.
func (x *Item) Validate() (err error) {
	return
}

type AssistantResp struct {
	Id      *string  `json:"id,omitempty" form:"id"`
	Data    *string  `json:"data,omitempty" form:"data"`
	Payload *Payload `json:"payload,omitempty" form:"payload"`
	Image   []byte   `json:"image,omitempty" form:"image"`
}

type Payload struct {
	FieldType *PayloadTypeAsString `json:"FieldType" form:"FieldType" validate:"required"`
	Payload1  *Payload_1           `json:"Payload_1,omitempty" form:"Payload_1"`
	Payload2  *Payload_2           `json:"Payload_2,omitempty" form:"Payload_2"`
	Payload3  *Payload_3           `json:"Payload_3,omitempty" form:"Payload_3"`
}

type Payload_1 struct {
}

type Payload_2 struct {
}

type Payload_3 struct {
}
