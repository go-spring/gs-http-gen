/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package golang

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/go-spring/gs-http-gen/gen/generator"
	"github.com/go-spring/gs-http-gen/lib/tidl"
	"github.com/go-spring/gs-http-gen/lib/vidl"
)

// typeTmpl is a Go template used to generate Go types, constants, enums, and structs
// from the parsed IDL definitions. It automatically generates methods for getters,
// setters, validation, binding from HTTP requests, and string representation.
var typeTmpl = template.Must(template.New("type").
	Funcs(map[string]any{
		"TrimPrefix": strings.TrimPrefix,
		"OptionalBaseType": func(k TypeKind) bool {
			return k == TypeKindOptionalBaseType
		},
		"OptionalEnumType": func(k TypeKind) bool {
			return k == TypeKindOptionalEnumType
		},
	}).
	Parse(`
// Code generated by gs-http-gen compiler. DO NOT EDIT.

package {{.Package}}

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
)

var _ = errors.New
var _ = strings.Count
var _ = http.NewServeMux

{{ range $c := .Consts }}
{{$c.Comment}}
const {{$c.Name}} {{$c.Type}} = {{$c.Value}}
{{end}}

{{ range $e := .Enums }}
	{{$e.Comment}}
	type {{$e.Name}} int32

	const (
		{{range $f := $e.Fields}}
			{{- if $f.Comment}}
				{{$f.Comment}}
			{{- end}}
			{{$e.Name}}_{{$f.Name}} {{$e.Name}} = {{$f.Value}}
		{{- end}}
	)

	var (
		{{$e.Name}}_name = map[{{$e.Name}}]string{
			{{- range $f := $e.Fields}}
				{{$f.Value}} : "{{$f.Name}}",
			{{- end}}
		}
		{{$e.Name}}_value = map[string]{{$e.Name}}{
			{{- range $f := $e.Fields}}
				"{{$f.Name}}" : {{$f.Value}},
			{{- end}}
		}
	)

	// {{$e.Name}}AsString wraps {{$e.Name}} to encode/decode as a JSON string
	type {{$e.Name}}AsString {{$e.Name}}

	// MarshalJSON implements custom JSON encoding for the enum as a string
	func (x {{$e.Name}}AsString) MarshalJSON() ([]byte, error) {
		if s, ok := {{$e.Name}}_name[{{$e.Name}}(x)]; ok {
			return []byte(fmt.Sprintf("\"%s\"", s)), nil
		}
		return nil, fmt.Errorf("invalid {{$e.Name}}: %d", x)
	}

	// UnmarshalJSON implements custom JSON decoding for the enum from a string
	func (x *{{$e.Name}}AsString) UnmarshalJSON(data []byte) error {
		str := strings.Trim(string(data), "\"")
		if v, ok := {{$e.Name}}_value[str]; ok {
			*x = {{$e.Name}}AsString(v)
			return nil
		}
		return fmt.Errorf("invalid {{$e.Name}} value: %q", str)
	}

	// OneOf{{$e.Name}} is usually used for validation.
	func OneOf{{$e.Name}}(i {{$e.Name}}) bool {
		_, ok := {{$e.Name}}_name[i]
		return ok
	}

{{end}}

{{range $s := .Structs}}
	{{$s.Comment}}
	type {{$s.Name}} struct {
		{{- range $f := $s.Fields}}
			{{- if $f.Comment}}
				{{$f.Comment}}
			{{- end}}
			{{$f.Name}} {{$f.Type}} {{$f.Tag}}
		{{- end}}
	}

	// New{{$s.Name}} creates a new instance of the struct and sets default values if defined
	func New{{$s.Name}}() *{{$s.Name}} {
		return &{{$s.Name}}{
			{{- range $f := $s.Fields}}
				{{- if $f.Default}}
			{{$f.Name}}: {{$f.Default}},
				{{- end}}
			{{- end}}
		}
	}

	// New implements the Object interface
	func (x *{{$s.Name}}) New() any {
		return New{{$s.Name}}()
	}

	{{range $f := $s.Fields}}
		// Get{{$f.Name}} returns the value of {{$f.Name}}
		func (x *{{$s.Name}}) Get{{$f.Name}}() (r {{$f.Type}}) {
			if x != nil {
				return x.{{$f.Name}}
			}
			return r
		}

		// Set{{$f.Name}} sets the value of {{$f.Name}}
		{{- if or (OptionalBaseType $f.TypeKind) (OptionalEnumType $f.TypeKind)}}
			func (x *{{$s.Name}}) Set{{$f.Name}}(v {{TrimPrefix $f.Type "*"}}) {
				if x != nil {
					x.{{$f.Name}} = &v
				}
			}
		{{- else}}
			func (x *{{$s.Name}}) Set{{$f.Name}}(v {{$f.Type}}) {
				if x != nil {
					x.{{$f.Name}} = v
				}
			}
		{{- end}}
	{{end}}

	// Binding extracts non-body values (header, path, query) from *http.Request
	func (x *{{$s.Name}}) Binding(r *http.Request) error {
		{{- if $s.BindingCount}}
			return Binding(r, []BindingField {
				{{- range $f := $s.Fields}}
					{{- if $f.Binding}}
				{"{{$s.Name}}.{{$f.Name}}", "{{$f.Binding.From}}", "{{$f.Binding.Name}}", &x.{{$f.Name}}},
					{{- end}}
				{{- end}}
			})
		{{- else}}
			return nil
		{{- end}}
	}

	// Validate checks field values using generated validation expressions
	func (x *{{$s.Name}}) Validate() error {
		{{- range $f := $s.Fields}}
			{{- if $f.Validate}}
		{{$f.Validate}}
			{{- end}}
		{{- end}}
		return nil
	}

	func (x *{{$s.Name}}) String() string {
		if x == nil {
			return "<nil>"
		}
		return fmt.Sprintf("{{$s.Name}}(%+v)", *x)
	}

{{end}}
`))

// genType generates a Go type file corresponding to the IDL file.
// It includes constants, enums, and struct types.
func (g *Generator) genType(ctx Context, fileName string, doc tidl.Document) error {
	consts, err := convertConsts(ctx, doc)
	if err != nil {
		return err
	}
	enums, err := convertEnums(ctx, doc)
	if err != nil {
		return err
	}
	types, err := convertTypes(ctx, doc)
	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	err = typeTmpl.Execute(buf, map[string]any{
		"Package": ctx.config.PackageName,
		"Consts":  consts,
		"Enums":   enums,
		"Structs": types,
	})
	if err != nil {
		return err
	}

	fileName = fileName[:strings.LastIndex(fileName, ".")] + ".go"
	fileName = filepath.Join(ctx.config.OutputDir, fileName)
	return formatFile(fileName, buf.Bytes())
}

// genComment generates the comment string
func genComment(c tidl.Comments) string {
	var comment string
	for _, s := range c.Top {
		comment += s.Text
	}
	if c.Right != nil {
		comment += "\n" + c.Right.Text
	}
	return comment
}

// Const represents a Go constant
type Const struct {
	Type    string
	Name    string
	Value   string
	Comment string
}

// convertConsts converts IDL constants to Go constants
func convertConsts(ctx Context, doc tidl.Document) ([]Const, error) {
	var ret []Const
	for _, c := range doc.Consts {
		typeName, err := getTypeName(ctx, tidl.BaseType{
			Name: c.Type,
		}, nil)
		if err != nil {
			return nil, err
		}
		ret = append(ret, Const{
			Name:    c.Name,
			Type:    typeName,
			Value:   c.Value,
			Comment: genComment(c.Comments),
		})
	}
	return ret, nil
}

// Enum represents a Go enum
type Enum struct {
	Name    string
	Fields  []EnumField
	Comment string
}

// EnumField represents a single field in a Go enum
type EnumField struct {
	Name    string
	Value   int64
	Comment string
}

// convertEnums converts IDL enums to Go enums
func convertEnums(ctx Context, doc tidl.Document) ([]Enum, error) {
	var ret []Enum
	for _, e := range doc.Enums {
		var fields []EnumField
		for _, f := range e.Fields {
			fields = append(fields, EnumField{
				Name:    f.Name,
				Value:   f.Value,
				Comment: genComment(f.Comments),
			})
		}
		ret = append(ret, Enum{
			Name:    tidl.CapitalizeASCII(e.Name),
			Fields:  fields,
			Comment: genComment(e.Comments),
		})
	}
	for _, t := range doc.Types {
		if !t.OneOf {
			continue
		}
		name := tidl.CapitalizeASCII(t.Name) + "Type"
		var fields []EnumField
		for i, f := range t.Fields {
			fields = append(fields, EnumField{
				Name:  generator.ToPascal(f.Name),
				Value: int64(i),
			})
		}
		ret = append(ret, Enum{
			Name:   name,
			Fields: fields,
		})
	}
	return ret, nil
}

// TypeKind represents kind of a Go field type
type TypeKind int

const (
	TypeKindUnknown TypeKind = iota
	TypeKindBaseType
	TypeKindOptionalBaseType
	TypeKindEnumType
	TypeKindOptionalEnumType
	TypeKindStructType
	TypeKindOptionalStructType
	TypeKindListType
	TypeKindMapType
)

// Type represents a Go struct
type Type struct {
	Name    string
	Fields  []TypeField
	Comment string
}

// Binding represents a field binding from headers, path, or query
type Binding struct {
	From string // Source: header/path/query
	Name string // Field name in the source
}

// TypeField represents a field in a Go struct
type TypeField struct {
	Type     string
	TypeKind TypeKind
	Name     string
	Default  *string
	Tag      string
	Validate *string
	Binding  *Binding
	Comment  string
}

// BindingCount returns the number of fields in the struct that have binding info
func (t *Type) BindingCount() int {
	var count int
	for _, f := range t.Fields {
		if f.Binding != nil {
			count++
		}
	}
	return count
}

// convertTypes converts IDL struct types to Go struct types
func convertTypes(ctx Context, doc tidl.Document) (_ []Type, err error) {
	var ret []Type

	// Handle type keyword defined structs
	for _, t := range doc.Types {
		// Skip generic types (they need instantiation)
		if t.GenericName != nil {
			continue
		}
		var r Type
		if t.Redefined != nil {
			r, err = convertRedefinedType(ctx, t)
		} else {
			r, err = convertType(ctx, t)
		}
		if err != nil {
			return nil, err
		}
		ret = append(ret, r)
	}

	// Handle RPC response types with generics
	for _, c := range doc.RPCs {
		if c.Response.Stream || c.Response.UserType == nil {
			continue
		}
		r, err := convertResponseType(ctx, c.Name, c.Response)
		if err != nil {
			return nil, err
		}
		ret = append(ret, r)
	}
	return ret, nil
}

// convertResponseType instantiates a generic response type for RPC
func convertResponseType(ctx Context, rpcName string, respType tidl.RespType) (Type, error) {
	t, ok := tidl.GetType(ctx.files, respType.TypeName)
	if !ok {
		return Type{}, fmt.Errorf("type %s not found", respType.TypeName)
	}

	typeName := tidl.CapitalizeASCII(rpcName)
	typeName += tidl.CapitalizeASCII(t.Name)
	typeName += tidl.CapitalizeASCII(respType.UserType.Name)

	r := tidl.Type{
		Name:     typeName,
		Position: t.Position,
		Comments: t.Comments,
	}

	// Replace generic type fields
	for _, f := range t.Fields {
		u, ok := f.FieldType.(tidl.UserType)
		if ok && u.Name == *t.GenericName {
			f.FieldType = *respType.UserType
		}
		r.Fields = append(r.Fields, f)
	}

	return convertType(ctx, r)
}

// convertRedefinedType instantiates a redefined generic struct type
func convertRedefinedType(ctx Context, r tidl.Type) (Type, error) {
	t, ok := tidl.GetType(ctx.files, r.Redefined.Name)
	if !ok {
		return Type{}, fmt.Errorf("type %s not found", r.Redefined.Name)
	}

	var fields []tidl.TypeField
	for _, f := range t.Fields {
		f.FieldType = resolveGenericType(f.FieldType, *t.GenericName, r.Redefined)
		fields = append(fields, f)
	}

	return convertType(ctx, tidl.Type{
		Name:     r.Name,
		Fields:   fields,
		Position: r.Position,
		Comments: r.Comments,
	})
}

// resolveGenericType replaces a generic type in a field with a concrete type
func resolveGenericType(t tidl.TypeDefinition, genericName string, r *tidl.RedefinedType) tidl.TypeDefinition {
	switch u := t.(type) {
	case tidl.UserType:
		if u.Name == genericName {
			return r.GenericType
		}
		return u
	case tidl.ListType:
		u.Item = resolveGenericType(u.Item, genericName, r)
		return u
	case tidl.MapType:
		u.Value = resolveGenericType(u.Value, genericName, r)
		return u
	default:
		return t
	}
}

// convertType converts an IDL struct type to a Go struct type
func convertType(ctx Context, t tidl.Type) (Type, error) {
	r := Type{
		Name: tidl.CapitalizeASCII(t.Name),
	}

	if t.OneOf {
		r.Fields = append(r.Fields, TypeField{
			Type:     r.Name + "Type",
			TypeKind: TypeKindEnumType,
			Name:     "FieldType",
			Tag:      "`json:\"field_type\"`",
		})
	}

	for _, f := range t.Fields {

		// Handle embedded types (flatten their fields into the struct)
		if ft, ok := f.FieldType.(tidl.EmbedType); ok {
			et, ok := tidl.GetType(ctx.files, ft.Name)
			if !ok {
				return Type{}, fmt.Errorf("embedded type %s not found for field in struct %s", ft.Name, r.Name)
			}
			rt, err := convertType(ctx, et)
			if err != nil {
				return Type{}, fmt.Errorf("failed to convert embedded type %s in struct %s: %w", ft.Name, r.Name, err)
			}
			// Append embedded type's fields
			r.Fields = append(r.Fields, rt.Fields...)
			continue
		}

		// Get field name and Go type
		fieldName := generator.ToPascal(f.Name)
		typeName, err := getTypeName(ctx, f.FieldType, f.Annotations)
		if err != nil {
			return Type{}, err
		}

		// Get the type kind of the field (base, enum, struct, list, map)
		typeKind, err := getTypeKind(ctx, typeName)
		if err != nil {
			return Type{}, err
		}

		// Parse default value if specified
		defVal, err := parseDefault(ctx, typeName, f.Default)
		if err != nil {
			return Type{}, err
		}

		// Parse binding information from annotations
		binding, err := parseBinding(f.Annotations)
		if err != nil {
			return Type{}, err
		}

		// Generate struct tag for the field
		fieldTag, err := genFieldTag(f.Name, typeName, f.Annotations, binding)
		if err != nil {
			return Type{}, err
		}

		// Generate validation code for the field
		validate, err := genValidate(r.Name, fieldName, typeName, f.Annotations, ctx.funcs)
		if err != nil {
			return Type{}, err
		}

		// Append the field to the struct
		r.Fields = append(r.Fields, TypeField{
			Type:     typeName,
			TypeKind: typeKind,
			Name:     fieldName,
			Default:  defVal,
			Tag:      fieldTag,
			Validate: validate,
			Binding:  binding,
			Comment:  genComment(f.Comments),
		})
	}
	return r, nil
}

// getTypeName returns the Go type name for a given IDL type.
// It also handles the "go.type" annotation with the highest priority.
func getTypeName(ctx Context, t tidl.TypeDefinition, arr []tidl.Annotation) (string, error) {

	// Handle go.type annotation
	if a, ok := tidl.GetOneOfAnnotation(arr, "go.type"); ok && a.Value != nil {
		s := strings.Trim(strings.TrimSpace(*a.Value), "\"")
		return s, nil
	}

	switch ft := t.(type) {
	case tidl.AnyType:
		return "", fmt.Errorf("any type must have go.type annotation")
	case tidl.BaseType:
		var typeName string
		switch ft.Name {
		case "string":
			typeName = "string"
		case "int":
			typeName = "int64"
		case "float":
			typeName = "float64"
		case "bool":
			typeName = "bool"
		default:
			return "", fmt.Errorf("unknown base type: %s", ft.Name)
		}
		if ft.Optional {
			typeName = "*" + typeName
		}
		return typeName, nil
	case tidl.UserType:
		typeName := tidl.CapitalizeASCII(ft.Name)
		if ft.Optional {
			typeName = "*" + typeName
		}

		// Handle enum_as_string annotation
		if _, ok := tidl.GetOneOfAnnotation(arr, "enum_as_string"); ok {
			if _, ok := tidl.GetEnum(ctx.files, ft.Name); !ok {
				return "", fmt.Errorf("enum %s not found", ft.Name)
			}
			typeName += "AsString"
		}
		return typeName, nil
	case tidl.ListType:
		itemType, err := getTypeName(ctx, ft.Item, nil)
		if err != nil {
			return "", err
		}
		return "[]" + itemType, nil
	case tidl.MapType:
		keyType := "string"
		if ft.Key == "int" {
			keyType = "int64"
		}
		valueType, err := getTypeName(ctx, ft.Value, nil)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("map[%s]%s", keyType, valueType), nil
	case tidl.BinaryType:
		// todo (lvan100) handle file
		return "[]byte", nil
	default:
		return "", fmt.Errorf("unknown type: %s", t.Text())
	}
}

// getTypeKind returns the category of a Go type (base, optional base, enum, struct, etc.)
func getTypeKind(ctx Context, typeName string) (TypeKind, error) {
	optional := strings.HasPrefix(typeName, "*")
	if optional {
		typeName = strings.TrimPrefix(typeName, "*")
	}

	switch typeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "string", "bool":
		if optional {
			return TypeKindOptionalBaseType, nil
		}
		return TypeKindBaseType, nil
	default: // for linter
	}

	switch {
	case strings.HasPrefix(typeName, "[]"):
		if optional {
			return TypeKindUnknown, fmt.Errorf("list type can not be optional")
		}
		return TypeKindListType, nil
	case strings.HasPrefix(typeName, "map["):
		if optional {
			return TypeKindUnknown, fmt.Errorf("map type can not be optional")
		}
		return TypeKindMapType, nil
	default:
		if _, ok := tidl.GetEnum(ctx.files, strings.TrimSuffix(typeName, "AsString")); ok {
			if optional {
				return TypeKindOptionalEnumType, nil
			}
			return TypeKindEnumType, nil
		}
		if _, ok := tidl.GetType(ctx.files, typeName); ok {
			if optional {
				return TypeKindOptionalStructType, nil
			}
			return TypeKindStructType, nil
		}
		return TypeKindUnknown, fmt.Errorf("unknown type: %s", typeName)
	}
}

// parseDefault parses the default value of a field based on its type
func parseDefault(ctx Context, typeName string, v *string) (*string, error) {
	if v == nil {
		return nil, nil
	}

	baseType := strings.TrimPrefix(typeName, "*")
	switch baseType {
	case "bool":
		return v, nil
	case "int", "int8", "int16", "int32", "int64":
		s := fmt.Sprintf("%s(%s)", baseType, *v)
		return &s, nil
	case "uint", "uint8", "uint16", "uint32", "uint64":
		s := fmt.Sprintf("%s(%s)", baseType, *v)
		return &s, nil
	case "float32", "float64":
		s := fmt.Sprintf("%s(%s)", baseType, *v)
		return &s, nil
	case "string":
		return v, nil
	default:
		if parts := strings.Split(*v, "."); len(parts) == 2 {
			// Handle enum values like EnumName.VALUE
			asString := strings.HasSuffix(typeName, "AsString")
			typeNameTrimmed := strings.TrimSuffix(typeName, "AsString")
			if _, ok := tidl.GetEnum(ctx.files, typeNameTrimmed); !ok {
				return v, nil // Treat as a regular string
			}
			s := tidl.CapitalizeASCII(parts[0]) + "_" + parts[1]
			if asString {
				s = fmt.Sprintf("%sAsString(%s)", typeNameTrimmed, s)
			}
			return &s, nil
		} else { // Treat as a regular string
			return v, nil
		}
	}
}

// parseBinding parses a field's binding information from annotations.
// It supports "header", "path", or "query" annotations.
func parseBinding(arr []tidl.Annotation) (*Binding, error) {
	a, ok := tidl.GetOneOfAnnotation(arr, "header", "path", "query")
	if !ok {
		return nil, nil
	}
	if a.Value == nil {
		return nil, fmt.Errorf("annotation %s value is nil", a.Key)
	}
	val := strings.Trim(*a.Value, "\"")
	return &Binding{From: a.Key, Name: val}, nil
}

// genFieldTag generates the struct tag for a field.
// It includes JSON tags and optional binding tags.
func genFieldTag(fieldName, typeName string, arr []tidl.Annotation, binding *Binding) (string, error) {
	var tags []string

	// Generate JSON tag
	jsonTag := fieldName
	if a, ok := tidl.GetOneOfAnnotation(arr, "json"); ok {
		if a.Value == nil {
			return "", fmt.Errorf("annotation json value is nil")
		}
		s := strings.TrimSpace(*a.Value)
		if s == "" {
			return "", fmt.Errorf("annotation json value is empty")
		}
		jsonTag = strings.Trim(s, "\"") // Remove quotes
	}

	omitZero := false
	omitEmpty := strings.HasPrefix(typeName, "*")

	for s := range strings.SplitSeq(jsonTag, ",") {
		switch strings.TrimSpace(s) {
		case "omitempty":
			omitEmpty = true
		case "non-omitempty":
			omitEmpty = false
		case "omitzero":
			omitZero = true
		}
	}

	if omitEmpty {
		jsonTag += ",omitempty"
	}
	if omitZero {
		jsonTag += ",omitzero"
	}
	tags = append(tags, fmt.Sprintf("json:\"%s\"", jsonTag))

	// Generate binding tag
	if binding != nil {
		tags = append(tags, fmt.Sprintf("%s:\"%s\"", binding.From, binding.Name))
	}

	return "`" + strings.Join(tags, " ") + "`", nil
}

// ValidateFunc represents a custom validation function
type ValidateFunc struct {
	Name      string
	FieldType string
}

// builtinFuncs is a set of built-in validation functions
var builtinFuncs = map[string]struct{}{
	"len": {},
}

// genValidate generates validation code for a field based on annotations.
// It returns a Go code snippet for validating the field.
func genValidate(receiverType, fieldName, fieldType string, arr []tidl.Annotation, funcs map[string]ValidateFunc) (*string, error) {
	optional := strings.HasPrefix(fieldType, "*")
	a, ok := tidl.GetOneOfAnnotation(arr, "validate")
	if !ok {
		return nil, nil
	}
	if a.Value == nil {
		return nil, fmt.Errorf("annotation validate value is nil")
	}

	// Unquote the validation string
	strValue, err := strconv.Unquote(*a.Value)
	if err != nil {
		return nil, fmt.Errorf("annotation validate value is not properly quoted")
	}
	if strValue == "" {
		return nil, fmt.Errorf("annotation validate value is empty")
	}

	// Parse the validation expression
	expr, err := vidl.Parse(strValue)
	if err != nil {
		return nil, err
	}

	dollar := "x." + fieldName
	if optional {
		dollar = "*" + dollar
	}

	// Generate the validation expression code
	str, err := genValidateExpr(dollar, fieldType, expr, funcs)
	if err != nil {
		return nil, err
	}

	// Wrap in an if statement returning an error on failure
	str = fmt.Sprintf(`if !(%s) {
		return errors.New("validate failed on %s.%s")
	}`, str, receiverType, fieldName)

	// Only validate optional fields if they are non-nil
	if optional {
		str = fmt.Sprintf(`if x.%s != nil { %s }`, fieldName, str)
	}

	return &str, nil
}

// genValidateExpr recursively generates Go code for a validation expression
func genValidateExpr(fieldName, fieldType string, expr vidl.Expr, funcs map[string]ValidateFunc) (string, error) {
	switch x := expr.(type) {
	case vidl.BinaryExpr:
		if x.Left == nil {
			return "", nil
		}
		left, err := genValidateExpr(fieldName, fieldType, x.Left, funcs)
		if err != nil {
			return "", err
		}
		if x.Right == nil {
			return left, nil
		}
		right, err := genValidateExpr(fieldName, fieldType, x.Right, funcs)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("%s %s %s", left, x.Op, right), nil

	case vidl.UnaryExpr:
		str, err := genValidateExpr(fieldName, fieldType, x.Expr, funcs)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("%s%s", x.Op, str), nil

	case *vidl.FuncCall:
		if len(x.Args) == 0 {
			return x.Name + "()", nil
		}

		// Register custom validation functions
		if _, ok := builtinFuncs[x.Name]; !ok {
			if len(x.Args) != 1 {
				return "", fmt.Errorf("func %s only accepts 1 argument of type %s", x.Name, fieldType)
			}
			if !strings.HasPrefix(x.Name, "OneOf") {
				if f, ok := funcs[x.Name]; ok {
					if f.FieldType != fieldType {
						return "", fmt.Errorf("func %s only accepts type %s", x.Name, f.FieldType)
					}
				} else {
					funcs[x.Name] = ValidateFunc{
						Name:      x.Name,
						FieldType: fieldType,
					}
				}
			}
		} else {
			switch x.Name {
			case "len":
				if len(x.Args) != 1 {
					return "", fmt.Errorf("func len only accepts 1 argument")
				}
			default: // for linter
			}
		}

		var args []string
		for _, arg := range x.Args {
			str, err := genValidateExpr(fieldName, fieldType, arg, funcs)
			if err != nil {
				return "", err
			}
			args = append(args, str)
		}
		return fmt.Sprintf("%s(%s)", x.Name, strings.Join(args, ", ")), nil

	case *vidl.InnerExpr:
		str, err := genValidateExpr(fieldName, fieldType, x.Expr, funcs)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s)", str), nil

	case vidl.PrimaryExpr:
		if x.Inner != nil {
			return genValidateExpr(fieldName, fieldType, x.Inner, funcs)
		}
		if x.Call != nil {
			return genValidateExpr(fieldName, fieldType, x.Call, funcs)
		}
		if x.Value == "$" {
			return fieldName, nil
		}
		return x.Value, nil

	default:
		return "", fmt.Errorf("unknown expression type: %s", x.Text())
	}
}
