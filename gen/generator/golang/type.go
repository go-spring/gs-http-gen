package golang

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/go-spring/gs-http-gen/gen/generator"
	"github.com/go-spring/gs-http-gen/lib/parser"
)

var typeTmpl = template.Must(template.New("type").Parse(`
// Code generated by gs-http-gen compiler. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
)

{{ range $e := .Enums }}
	type {{$e.Name}} int32

	const(
		{{range $f := $e.Fields}}
			{{$e.Name}}_{{$f.Name}} {{$e.Name}} = {{$f.Value}}
		{{- end}}
	)
	
	var (
		{{$e.Name}}_name = map[int32]string{
			{{- range $f := $e.Fields}}
				{{$f.Value}} : "{{$f.Name}}",
			{{- end}}
		}
		{{$e.Name}}_value = map[string]int32{
			{{- range $f := $e.Fields}}
				"{{$f.Name}}" : {{$f.Value}},
			{{- end}}
		}
	)

	func OneOf{{$e.Name}}(i int32) bool {
		_, ok := {{$e.Name}}_name[i]
		return ok
	}

{{end}}

{{range $s := .Structs}}
	type {{$s.Name}} struct {
		{{- range $f := $s.Fields}}
			{{$f.Name}} {{$f.Type}} {{$f.Tag}}
		{{- end}}
	}

	func New{{$s.Name}}() *{{$s.Name}} {
		return &{{$s.Name}}{}
	}

	func (x *{{$s.Name}}) New() any {
		return New{{$s.Name}}()
	}

	{{range $f := $s.Fields}}
		func (x *{{$s.Name}}) Get{{$f.Name}}() (r {{$f.Type}}) {
			if x != nil {
				return x.{{$f.Name}}
			}
			return r
		}

		func (x *{{$s.Name}}) Set{{$f.Name}}(v {{$f.Type}}) {
			if x != nil {
				x.{{$f.Name}} = v
			}
		}
	{{end}}

	func (p *{{$s.Name}}) String() string {
		if p == nil {
			return "<nil>"
		}
		return fmt.Sprintf("{{$s.Name}}(%+v)", *p)
	}

{{end}}

`))

func (g *Generator) genType(ctx Context, fileName string, doc parser.Document) error {
	types, err := expandTypes(ctx, doc)
	if err != nil {
		return err
	}
	buf := &bytes.Buffer{}
	err = typeTmpl.Execute(buf, map[string]interface{}{
		"Package": ctx.config.PkgName,
		"Enums":   doc.Enums,
		"Structs": types,
	})
	if err != nil {
		return err
	}
	b, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	fileName = fileName[:strings.LastIndex(fileName, ".")] + ".go"
	fileName = filepath.Join(ctx.config.OutDir, fileName)
	return os.WriteFile(fileName, b, os.ModePerm)
}

type Type struct {
	Name   string
	Fields []TypeField
}

type TypeField struct {
	Type    string
	Name    string
	Default *string
	Tag     string
}

func expandTypes(ctx Context, doc parser.Document) ([]Type, error) {
	var ret []Type
	for _, t := range doc.Types {
		var (
			tmp Type
			err error
		)
		if t.Redefined != nil {
			tmp, err = expandRedefinedType(ctx, t)
		} else {
			if t.GenericName != nil {
				continue
			}
			tmp, err = expandType(ctx, t)
		}
		if err != nil {
			return nil, err
		}
		ret = append(ret, tmp)
	}
	for _, c := range doc.RPCs {
		if c.Response.Stream || c.Response.UserType == nil {
			continue
		}
		r, err := expandResponse(ctx, c.Response)
		if err != nil {
			return nil, err
		}
		ret = append(ret, r)
	}
	return ret, nil
}

func expandResponse(ctx Context, r parser.RespType) (Type, error) {
	t := generator.GetType(ctx.files, r.TypeName)
	if t == nil {
		return Type{}, fmt.Errorf("type %s not found", r.TypeName)
	}

	typeName := generator.ToPascal(t.Name)
	typeName += generator.ToPascal(r.UserType.Name)

	newT := &parser.Type{
		Name:     typeName,
		Position: t.Position,
		Comments: t.Comments,
	}

	for _, f := range t.Fields {
		u, ok := f.FieldType.(parser.UserType)
		if ok && u.Name == *t.GenericName {
			field := f
			field.FieldType = *r.UserType
			newT.Fields = append(newT.Fields, field)
		} else {
			newT.Fields = append(newT.Fields, f)
		}
	}
	return expandType(ctx, newT)
}

func expandRedefinedType(ctx Context, r *parser.Type) (Type, error) {
	t := generator.GetType(ctx.files, r.Redefined.Name)
	if t == nil {
		return Type{}, fmt.Errorf("type %s not found", r.Redefined.Name)
	}

	newT := &parser.Type{
		Name:     r.Name,
		Position: r.Position,
		Comments: r.Comments,
	}

	for _, f := range t.Fields {
		u, ok := f.FieldType.(parser.UserType)
		if ok && u.Name == *t.GenericName {
			field := f
			field.FieldType = r.Redefined.GenericType
			newT.Fields = append(newT.Fields, field)
		} else {
			newT.Fields = append(newT.Fields, f)
		}
	}
	return expandType(ctx, newT)
}

func expandType(ctx Context, t *parser.Type) (Type, error) {
	r := Type{
		Name: generator.ToPascal(t.Name),
	}
	for _, f := range t.Fields {
		field := TypeField{
			Name:    generator.ToPascal(f.Name),
			Default: f.Default,
		}
		{
			fieldTag, err := genFieldTag(f)
			if err != nil {
				return Type{}, err
			}
			field.Tag = fieldTag
		}
		switch ft := f.FieldType.(type) {
		case parser.EmbedType:
		case parser.AnyType:
			a, ok := generator.GetAnnotation(f.Annotations, "go.type")
			if !ok {
				return Type{}, fmt.Errorf("annotation go.type not found")
			}
			if a.Value == nil {
				return Type{}, fmt.Errorf("annotation go.type value is nil")
			}
			field.Type = *a.Value
		case parser.BaseType:
			var typeName string
			switch ft.Name {
			case "string":
				typeName = "string"
			case "int":
				typeName = "int64"
			case "float":
				typeName = "float64"
			case "bool":
				typeName = "bool"
			default: // for linter
				return Type{}, fmt.Errorf("unknown base type: %s", ft.Name)
			}
			if ft.Optional {
				typeName = "*" + typeName
			}
			a, ok := generator.GetAnnotation(f.Annotations, "go.type")
			if ok {
				if a.Value == nil {
					return Type{}, fmt.Errorf("annotation go.type value is nil")
				}
				typeName = *a.Value
			}
			field.Type = typeName
		case parser.UserType:
			field.Type = generator.ToPascal(ft.Name)
			if ft.Optional {
				field.Type = "*" + field.Type
			}
		case parser.BinaryType:
		case parser.ListType:
		case parser.MapType:
		}
		r.Fields = append(r.Fields, field)
	}
	return r, nil
}

func genFieldTag(f parser.TypeField) (string, error) {
	json := f.Name
	if a, ok := generator.GetAnnotation(f.Annotations, "json"); ok {
		if a.Value == nil {
			return "", fmt.Errorf("annotation json value is nil")
		}
		json = *a.Value
	}
	tag := fmt.Sprintf("`json:\"%s\"`", json)
	return tag, nil
}
