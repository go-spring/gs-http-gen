/*
 * Copyright 2025 The Go-Spring Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package golang

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"

	"github.com/go-spring/gs-http-gen/lib/tidl"
	"github.com/go-spring/gs-http-gen/lib/vidl"
)

// typeTmpl is a Go template used to generate Go source code from IDL definitions.
var typeTmpl = template.Must(template.New("type").
	Funcs(map[string]any{
		"TrimPrefix": strings.TrimPrefix,
		"OptionalBaseType": func(k TypeKind) bool {
			return k == TypeKindOptionalBaseType
		},
		"OptionalEnumType": func(k TypeKind) bool {
			return k == TypeKindOptionalEnumType
		},
	}).
	Parse(`
// Code generated by gs-http-gen compiler. DO NOT EDIT.

package {{.Package}}

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
)

var _ = errors.New
var _ = strings.Count
var _ = http.NewServeMux

{{ range $c := .Consts }}
{{- if $c.Comment }}
	{{$c.Comment}}
{{- end}}
const {{$c.Name}} {{$c.Type}} = {{$c.Value}}
{{end}}

{{ range $e := .Enums }}
	{{- if $e.Comment}}
		{{$e.Comment}}
	{{- end}}
	type {{$e.Name}} int32

	const (
		{{range $f := $e.Fields}}
			{{- if $f.Comment}}
				{{$f.Comment}}
			{{- end}}
			{{$e.Name}}_{{$f.Name}} {{$e.Name}} = {{$f.Value}}
		{{- end}}
	)

	var (
		{{$e.Name}}_name = map[{{$e.Name}}]string{
			{{- range $f := $e.Fields}}
				{{$f.Value}} : "{{$f.Name}}",
			{{- end}}
		}
		{{$e.Name}}_value = map[string]{{$e.Name}}{
			{{- range $f := $e.Fields}}
				"{{$f.Name}}" : {{$f.Value}},
			{{- end}}
		}
	)

	// OneOf{{$e.Name}} is usually used for validation.
	func OneOf{{$e.Name}}(i {{$e.Name}}) bool {
		_, ok := {{$e.Name}}_name[i]
		return ok
	}

	// {{$e.Name}}AsString wraps {{$e.Name}} to encode/decode as a JSON string.
	type {{$e.Name}}AsString {{$e.Name}}

	// MarshalJSON implements custom JSON encoding for the enum as a string.
	func (x {{$e.Name}}AsString) MarshalJSON() ([]byte, error) {
		if s, ok := {{$e.Name}}_name[{{$e.Name}}(x)]; ok {
			return []byte(fmt.Sprintf("\"%s\"", s)), nil
		}
		return nil, fmt.Errorf("invalid {{$e.Name}}: %d", x)
	}

	// UnmarshalJSON implements custom JSON decoding for the enum from a string.
	func (x *{{$e.Name}}AsString) UnmarshalJSON(data []byte) error {
		str := strings.Trim(string(data), "\"")
		if v, ok := {{$e.Name}}_value[str]; ok {
			*x = {{$e.Name}}AsString(v)
			return nil
		}
		return fmt.Errorf("invalid {{$e.Name}} value: %q", str)
	}
{{end}}

{{range $s := .Structs}}
	{{- if $s.Comment}}
		{{$s.Comment}}
	{{- end}}
	type {{$s.Name}} struct {
		ObjectBase
		{{- range $f := $s.Fields}}
			{{- if $f.Comment}}
				{{$f.Comment}}
			{{- end}}
			{{$f.Name}} {{$f.Type}} {{$f.Tag}}
		{{- end}}
	}

	// New returns a new instance (implements Object interface).
	func (x *{{$s.Name}}) New() any {
		return &{{$s.Name}}{}
	}

	{{- if $s.BindingCount}}
		// Binding extracts non-body values (header, path, query) from *http.Request.
		func (x *{{$s.Name}}) Binding(r *http.Request) error {
			return Binding(r, []BindingField {
				{{- range $f := $s.Fields}}
					{{- if $f.Binding}}
				{"{{$s.Name}}.{{$f.Name}}", "{{$f.Binding.From}}", "{{$f.Binding.Name}}", &x.{{$f.Name}}},
					{{- end}}
				{{- end}}
			})
		}
	{{- end}}

	{{- if $s.ValidateCount}}
		// Validate checks field values using generated validation expressions.
		func (x *{{$s.Name}}) Validate() error {
			{{- range $f := $s.Fields}}
				{{- if $f.Validate}}
			{{$f.Validate}}
				{{- end}}
			{{- end}}
			return nil
		}
	{{- end}}

	func (x *{{$s.Name}}) String() string {
		if x == nil {
			return "<nil>"
		}
		return fmt.Sprintf("{{$s.Name}}(%+v)", *x)
	}

{{end}}
`))

// genType generates a Go source file corresponding to the IDL file.
// It includes constants, enums, and struct types.
func (g *Generator) genType(ctx Context, fileName string, doc tidl.Document) error {
	consts, err := convertConsts(ctx, doc)
	if err != nil {
		return fmt.Errorf("convert consts error: %w", err)
	}
	enums, err := convertEnums(ctx, doc)
	if err != nil {
		return fmt.Errorf("convert enums error: %w", err)
	}
	types, err := convertTypes(ctx, doc)
	if err != nil {
		return fmt.Errorf("convert types error: %w", err)
	}

	buf := &bytes.Buffer{}
	err = typeTmpl.Execute(buf, map[string]any{
		"Package": ctx.config.GoPackage,
		"Consts":  consts,
		"Enums":   enums,
		"Structs": types,
	})
	if err != nil {
		return fmt.Errorf("execute template error: %w", err)
	}

	fileName = fileName[:strings.LastIndex(fileName, ".")] + ".go"
	fileName = filepath.Join(ctx.config.OutputDir, fileName)
	return formatFile(fileName, buf.Bytes())
}

// Const represents a Go constant
type Const struct {
	Type    string
	Name    string
	Value   string
	Comment string
}

// convertConsts converts IDL constants to Go constants
func convertConsts(ctx Context, doc tidl.Document) ([]Const, error) {
	var ret []Const
	for _, c := range doc.Consts {
		t := tidl.BaseType{Name: c.Type}
		typeName, err := getTypeName(ctx, t, nil)
		if err != nil {
			return nil, err
		}
		ret = append(ret, Const{
			Name:    c.Name,
			Type:    typeName,
			Value:   c.Value,
			Comment: formatComment(c.Comments),
		})
	}
	return ret, nil
}

// Enum represents a Go enum
type Enum struct {
	Name    string
	Fields  []EnumField
	Comment string
}

// EnumField represents a single field in a Go enum
type EnumField struct {
	Name    string
	Value   int64
	Comment string
}

// convertEnums converts IDL enums to Go enums
func convertEnums(ctx Context, doc tidl.Document) ([]Enum, error) {
	var ret []Enum

	// Convert standard enums
	for _, e := range doc.Enums {
		var fields []EnumField
		for _, f := range e.Fields {
			fields = append(fields, EnumField{
				Name:    f.Name,
				Value:   f.Value,
				Comment: formatComment(f.Comments),
			})
		}
		ret = append(ret, Enum{
			Name:    e.Name,
			Fields:  fields,
			Comment: formatComment(e.Comments),
		})
	}

	// Convert enums from oneof types
	for _, t := range doc.Types {
		if !t.OneOf { // skip non-oneof types
			continue
		}
		var fields []EnumField
		for i, f := range t.Fields {
			fieldName, err := getJSONName(f.Name, f.Annotations)
			if err != nil {
				return nil, fmt.Errorf("get json name for type %s field %s error: %w", t.Name, f.Name, err)
			}
			fields = append(fields, EnumField{
				Name:  fieldName,
				Value: int64(i),
			})
		}
		ret = append(ret, Enum{
			Name:   t.Name + "Type",
			Fields: fields,
		})
	}
	return ret, nil
}

// getJSONName returns the JSON name for a struct field.
func getJSONName(fieldName string, arr []tidl.Annotation) (string, error) {
	if a, ok := tidl.GetAnnotation(arr, "json"); ok {
		if a.Value == nil {
			return "", fmt.Errorf(`annotation "json" value is nil`)
		}
		s := strings.TrimSpace(*a.Value)
		if s == "" {
			return "", fmt.Errorf(`annotation "json" value is empty`)
		}
		s = strings.Trim(s, "\"") // remove quotes
		s = strings.TrimSpace(strings.SplitN(s, ",", 2)[0])
		if s != "" {
			return s, nil
		}
	}
	return fieldName, nil
}

// TypeKind represents kind of a Go field type
type TypeKind int

const (
	TypeKindUnknown TypeKind = iota
	TypeKindBaseType
	TypeKindOptionalBaseType
	TypeKindEnumType
	TypeKindOptionalEnumType
	TypeKindStructType
	TypeKindOptionalStructType
	TypeKindListType
	TypeKindMapType
)

// Type represents a Go struct
type Type struct {
	Name    string
	Fields  []TypeField
	Comment string
}

// TypeField represents a field in a Go struct
type TypeField struct {
	Type     string
	TypeKind TypeKind
	Name     string
	Tag      string
	Validate *string
	Binding  *Binding
	Comment  string
}

// Binding represents a field binding from headers, path, or query
type Binding struct {
	From string // Source: header/path/query
	Name string // Field name in the source
}

// BindingCount returns the number of fields in the struct that have binding info
func (t *Type) BindingCount() int {
	var count int
	for _, f := range t.Fields {
		if f.Binding != nil {
			count++
		}
	}
	return count
}

// ValidateCount returns the number of fields in the struct that have validation expressions
func (t *Type) ValidateCount() int {
	var count int
	for _, f := range t.Fields {
		if f.Validate != nil {
			count++
		}
	}
	return count
}

// convertTypes converts IDL struct types to Go struct types
func convertTypes(ctx Context, doc tidl.Document) ([]Type, error) {
	var ret []Type
	for _, t := range doc.Types {
		// Skip generic types (they need instantiation via Redefined)
		if t.GenericName != nil {
			continue
		}
		var (
			typ Type
			err error
		)
		if t.Redefined != nil {
			typ, err = convertRedefinedType(ctx, t)
		} else {
			typ, err = convertType(ctx, t)
		}
		if err != nil {
			return nil, err
		}
		ret = append(ret, typ)
	}
	return ret, nil
}

// convertRedefinedType instantiates a redefined generic struct type
func convertRedefinedType(ctx Context, r tidl.Type) (Type, error) {

	t, ok := tidl.GetType(ctx.files, r.Redefined.Name)
	if !ok {
		err := fmt.Errorf("type %s not found", r.Redefined.Name)
		return Type{}, fmt.Errorf("convert redefined type %s error: %w", r.Name, err)
	}

	var fields []tidl.TypeField
	for _, f := range t.Fields {
		// Replace generic placeholders with concrete types
		f.FieldType = replaceGenericType(f.FieldType, *t.GenericName, r.Redefined.GenericType)
		fields = append(fields, f)
	}

	return convertType(ctx, tidl.Type{
		Name:     r.Name,
		Fields:   fields,
		Position: r.Position,
		Comments: r.Comments,
	})
}

// replaceGenericType replaces a generic type in a field with a concrete type
func replaceGenericType(t tidl.TypeDefinition, genericName string, genericType tidl.TypeDefinition) tidl.TypeDefinition {
	switch u := t.(type) {
	case tidl.UserType:
		if u.Name == genericName {
			return genericType
		}
		return u
	case tidl.ListType:
		u.Item = replaceGenericType(u.Item, genericName, genericType)
		return u
	case tidl.MapType:
		u.Value = replaceGenericType(u.Value, genericName, genericType)
		return u
	default:
		return t
	}
}

// convertType converts an IDL struct type to a Go struct type
func convertType(ctx Context, t tidl.Type) (Type, error) {
	r := Type{
		Name: t.Name,
	}

	// Handle oneof
	if t.OneOf {
		r.Fields = append(r.Fields, TypeField{
			Type:     r.Name + "TypeAsString",
			TypeKind: TypeKindEnumType,
			Name:     "FieldType",
			Tag:      "`json:\"field_type\"`",
		})
	}

	// Handle fields
	for _, f := range t.Fields {

		// Handle embedded types (flatten their fields into the struct)
		if embedType, ok := f.FieldType.(tidl.EmbedType); ok {
			srcType, ok := tidl.GetType(ctx.files, embedType.Name)
			if !ok {
				return Type{}, fmt.Errorf("embedded type %s not found for field in type %s", embedType.Name, r.Name)
			}
			retType, err := convertType(ctx, srcType)
			if err != nil {
				return Type{}, fmt.Errorf("failed to convert embedded type %s in type %s: %w", embedType.Name, r.Name, err)
			}
			// Append embedded type's fields
			r.Fields = append(r.Fields, retType.Fields...)
			continue
		}

		// Convert field name to PascalCase for Go
		fieldName := tidl.ToPascal(f.Name)

		// Determine Go type for the field
		typeName, err := getTypeName(ctx, f.FieldType, f.Annotations)
		if err != nil {
			return Type{}, fmt.Errorf("get type name for field %s in type %s error: %w", f.Name, r.Name, err)
		}

		// Determine the category of the field (base, enum, struct, list, map)
		typeKind, err := getTypeKind(ctx, typeName)
		if err != nil {
			return Type{}, fmt.Errorf("get type kind for field %s in type %s error: %w", f.Name, r.Name, err)
		}

		// Parse HTTP binding info from annotations (header, path, query)
		binding, err := parseBinding(f.Annotations)
		if err != nil {
			return Type{}, fmt.Errorf("parse binding for field %s in type %s error: %w", f.Name, r.Name, err)
		}

		// Generate struct tag for JSON, query/path/header bindings
		fieldTag, err := genFieldTag(f.Name, typeName, f.Annotations, binding)
		if err != nil {
			return Type{}, fmt.Errorf("generate field tag for field %s in type %s error: %w", f.Name, r.Name, err)
		}

		// Generate validation expressions for the field
		validate, err := genValidate(r.Name, fieldName, typeName, f.Annotations, ctx.funcs)
		if err != nil {
			return Type{}, fmt.Errorf("generate validate for field %s in type %s error: %w", f.Name, r.Name, err)
		}

		// Add the field to the struct
		r.Fields = append(r.Fields, TypeField{
			Type:     typeName,
			TypeKind: typeKind,
			Name:     fieldName,
			Tag:      fieldTag,
			Validate: validate,
			Binding:  binding,
			Comment:  formatComment(f.Comments),
		})
	}
	return r, nil
}

// getTypeName returns the Go type name for a given IDL type.
// It also respects the "go.type" annotation, which overrides the default type.
func getTypeName(ctx Context, t tidl.TypeDefinition, arr []tidl.Annotation) (string, error) {

	// Handle explicit "go.type" annotation
	if a, ok := tidl.GetAnnotation(arr, "go.type"); ok {
		if a.Value == nil {
			return "", fmt.Errorf(`annotation "go.type" must have a value`)
		}
		s := strings.Trim(strings.TrimSpace(*a.Value), "\"")
		if s == "" {
			return "", fmt.Errorf(`annotation "go.type" must not be empty`)
		}
		return s, nil
	}

	switch typ := t.(type) {
	case tidl.AnyType:
		return "", fmt.Errorf(`any type must have annotation "go.type"`)
	case tidl.BaseType:
		var typeName string
		switch typ.Name {
		case "string":
			typeName = "string"
		case "int":
			typeName = "int64"
		case "float":
			typeName = "float64"
		case "bool":
			typeName = "bool"
		default:
			return "", fmt.Errorf("unknown base type: %s", typ.Name)
		}
		if typ.Optional {
			typeName = "*" + typeName
		}
		return typeName, nil
	case tidl.UserType:
		typeName := typ.Name
		// Handle enum_as_string annotation
		if _, ok := tidl.GetAnnotation(arr, "enum_as_string"); ok {
			if _, ok := tidl.GetEnum(ctx.files, typ.Name); !ok {
				return "", fmt.Errorf("enum %s not found", typ.Name)
			}
			typeName += "AsString"
		}
		if typ.Optional {
			typeName = "*" + typeName
		}
		return typeName, nil
	case tidl.ListType:
		itemType, err := getTypeName(ctx, typ.Item, nil)
		if err != nil {
			return "", err
		}
		return "[]" + itemType, nil
	case tidl.MapType:
		keyType := "string"
		if typ.Key == "int" {
			keyType = "int64"
		}
		valueType, err := getTypeName(ctx, typ.Value, nil)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("map[%s]%s", keyType, valueType), nil
	case tidl.BinaryType:
		return "[]byte", nil // todo (lvan100) handle file
	default:
		return "", fmt.Errorf("unknown type: %s", t.Text())
	}
}

// getTypeKind categorizes a Go type for code generation purposes.
func getTypeKind(ctx Context, typeName string) (TypeKind, error) {
	typeName, optional := strings.CutPrefix(typeName, "*")

	switch typeName {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "string", "bool":
		if optional {
			return TypeKindOptionalBaseType, nil
		}
		return TypeKindBaseType, nil
	default: // for linter
	}

	switch {
	case strings.HasPrefix(typeName, "[]"):
		if optional {
			return TypeKindUnknown, fmt.Errorf("list type can not be optional")
		}
		return TypeKindListType, nil
	case strings.HasPrefix(typeName, "map["):
		if optional {
			return TypeKindUnknown, fmt.Errorf("map type can not be optional")
		}
		return TypeKindMapType, nil
	default:
		if _, ok := tidl.GetEnum(ctx.files, strings.TrimSuffix(typeName, "AsString")); ok {
			if optional {
				return TypeKindOptionalEnumType, nil
			}
			return TypeKindEnumType, nil
		}
		if _, ok := tidl.GetType(ctx.files, typeName); ok {
			if optional {
				return TypeKindOptionalStructType, nil
			}
			return TypeKindStructType, nil
		}
		return TypeKindUnknown, fmt.Errorf("unknown type: %s", typeName)
	}
}

// parseBinding parses a field's HTTP binding information from annotations.
// Supported sources: header, path, query.
func parseBinding(arr []tidl.Annotation) (*Binding, error) {
	a, ok := tidl.GetAnnotation(arr, "header", "path", "query")
	if !ok {
		return nil, nil
	}
	if a.Value == nil {
		return nil, fmt.Errorf("annotation %q value is nil", a.Key)
	}
	val := strings.TrimSpace(strings.Trim(*a.Value, "\""))
	if val == "" {
		return nil, fmt.Errorf("annotation %q value is empty", a.Key)
	}
	return &Binding{From: a.Key, Name: val}, nil
}

// genFieldTag generates the struct tag for a Go struct field.
// It includes JSON tags and optional binding tags (header, path, query).
func genFieldTag(fieldName, typeName string, arr []tidl.Annotation, binding *Binding) (string, error) {
	var tags []string

	var jsonName string
	var omitZero bool
	omitEmpty := strings.HasPrefix(typeName, "*")

	// Parse "json" annotation
	if a, ok := tidl.GetAnnotation(arr, "json"); ok {
		if a.Value == nil {
			return "", fmt.Errorf(`annotation "json" value is nil`)
		}
		s := strings.TrimSpace(*a.Value)
		if s == "" {
			return "", fmt.Errorf(`annotation "json" value is empty`)
		}
		s = strings.Trim(s, "\"") // Remove quotes
		for i, v := range strings.Split(s, ",") {
			v = strings.TrimSpace(v)
			if i == 0 {
				if v != "" {
					jsonName = v
				}
				continue
			}
			switch v {
			case "omitempty":
				omitEmpty = true
			case "non-omitempty":
				omitEmpty = false
			case "omitzero":
				omitZero = true
			default: // for linter
			}
		}
	}

	if jsonName == "" {
		jsonName += fieldName
	}
	if omitEmpty {
		jsonName += ",omitempty"
	}
	if omitZero {
		jsonName += ",omitzero"
	}
	tags = append(tags, fmt.Sprintf("json:\"%s\"", jsonName))

	// Generate binding tag
	if binding != nil {
		tags = append(tags, fmt.Sprintf("%s:\"%s\"", binding.From, binding.Name))
	}

	return "`" + strings.Join(tags, " ") + "`", nil
}

// ValidateFunc represents a custom validation function
type ValidateFunc struct {
	Name      string
	FieldType string
}

// builtinFuncs is a set of built-in validation functions
var builtinFuncs = map[string]struct{}{
	"len": {},
}

// genValidate generates validation code for a struct field based on its "validate" annotation.
// Returns a Go code snippet that checks the field and returns an error if validation fails.
func genValidate(receiverType, fieldName, fieldType string, arr []tidl.Annotation, funcs map[string]ValidateFunc) (*string, error) {
	a, ok := tidl.GetAnnotation(arr, "validate")
	if !ok {
		return nil, nil
	}
	if a.Value == nil {
		return nil, fmt.Errorf(`annotation "validate" value is nil`)
	}

	// Unquote the validation expression string
	strValue, err := strconv.Unquote(*a.Value)
	if err != nil {
		return nil, fmt.Errorf(`annotation "validate" value is not properly quoted`)
	}
	if strValue == "" {
		return nil, fmt.Errorf(`annotation "validate" value is empty`)
	}

	// Parse the validation expression
	expr, err := vidl.Parse(strValue)
	if err != nil {
		return nil, fmt.Errorf(`failed to parse validate expression %s: %w`, strValue, err)
	}

	optional := strings.HasPrefix(fieldType, "*")
	dollar := "x." + fieldName
	if optional {
		dollar = "*" + dollar
	}

	// Generate the Go expression for validation
	str, err := genValidateExpr(dollar, fieldType, expr, funcs)
	if err != nil {
		return nil, fmt.Errorf(`failed to generate validate expression for %s: %w`, strValue, err)
	}

	// Wrap in an if statement returning an error on failure
	str = fmt.Sprintf(`if !(%s) {
		return errors.New("validate failed on %s.%s")
	}`, str, receiverType, fieldName)

	if optional {
		str = fmt.Sprintf(`if x.%s != nil { %s }`, fieldName, str)
	}
	return &str, nil
}

// genValidateExpr recursively generates Go code for a validation expression
func genValidateExpr(fieldName, fieldType string, expr vidl.Expr, funcs map[string]ValidateFunc) (string, error) {
	switch x := expr.(type) {
	case vidl.BinaryExpr:
		if x.Left == nil {
			return "", nil
		}
		left, err := genValidateExpr(fieldName, fieldType, x.Left, funcs)
		if err != nil {
			return "", err
		}
		if x.Right == nil {
			return left, nil
		}
		right, err := genValidateExpr(fieldName, fieldType, x.Right, funcs)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("%s %s %s", left, x.Op, right), nil

	case vidl.UnaryExpr:
		str, err := genValidateExpr(fieldName, fieldType, x.Expr, funcs)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("%s%s", x.Op, str), nil

	case *vidl.FuncCall:
		if len(x.Args) == 0 {
			return x.Name + "()", nil
		}

		// Register or validate custom functions
		if _, ok := builtinFuncs[x.Name]; !ok {
			if len(x.Args) != 1 {
				return "", fmt.Errorf("func %s only accepts 1 argument of type %s", x.Name, fieldType)
			}
			if !strings.HasPrefix(x.Name, "OneOf") {
				if f, ok := funcs[x.Name]; ok {
					if f.FieldType != fieldType {
						return "", fmt.Errorf("func %s only accepts type %s", x.Name, f.FieldType)
					}
				} else {
					funcs[x.Name] = ValidateFunc{
						Name:      x.Name,
						FieldType: fieldType,
					}
				}
			}
		} else {
			// Validate built-in functions
			switch x.Name {
			case "len":
				if len(x.Args) != 1 {
					return "", fmt.Errorf("func len only accepts 1 argument")
				}
			default: // for linter
			}
		}

		var args []string
		for _, arg := range x.Args {
			str, err := genValidateExpr(fieldName, fieldType, arg, funcs)
			if err != nil {
				return "", err
			}
			args = append(args, str)
		}
		return fmt.Sprintf("%s(%s)", x.Name, strings.Join(args, ", ")), nil

	case *vidl.InnerExpr:
		str, err := genValidateExpr(fieldName, fieldType, x.Expr, funcs)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("(%s)", str), nil

	case vidl.PrimaryExpr:
		if x.Inner != nil {
			return genValidateExpr(fieldName, fieldType, x.Inner, funcs)
		}
		if x.Call != nil {
			return genValidateExpr(fieldName, fieldType, x.Call, funcs)
		}
		if x.Value == "$" {
			return fieldName, nil
		}
		return x.Value, nil

	default:
		return "", fmt.Errorf("unknown expression type: %s", x.Text())
	}
}
