# IDL 语法中文说明文档

## 概述

**gs-http-gen** 是一种面向 HTTP/RPC 场景专门设计的接口定义语言（Interface Definition Language，IDL），
用于统一描述**数据模型、接口契约以及服务交互方式**。

该语言支持对以下核心要素进行声明式定义：

* **基础常量与枚举**：用于表达固定值、状态集合及错误码等全局约束；
* **结构体与联合类型**：用于精确定义请求、响应及领域模型的数据结构；
* **RPC 服务接口**：用于描述基于 HTTP 的服务接口，支持普通请求/响应模式以及
  Server-Sent Events（SSE）等流式交互模式；
* **注解与校验规则**：用于补充序列化规则、路由信息、参数绑定方式以及运行时校验逻辑。

通过引入 gs-http-gen IDL，可以在接口设计阶段明确并固化以下关键约束：

* 前后端共享统一的数据结构定义，避免手写 DTO 带来的歧义；
* 接口协议、路由规则与参数绑定方式集中声明，减少隐式约定；
* 校验规则前置到接口定义层，提高接口稳定性与一致性；
* 为代码生成、接口治理、文档生成等自动化工具提供可靠输入。

gs-http-gen 的设计目标并非替代通用的序列化协议（如 Protobuf），
而是**聚焦于 HTTP API 场景**，在保持语义清晰和表达能力的同时，
尽可能降低接口定义与实现之间的认知成本。

## IDL 项目结构

一个完整且可被 gs-http-gen 工具正确解析的 IDL 项目，必须遵循约定的项目结构。
该结构用于统一组织项目元信息、接口定义文件以及公共类型声明，
以确保类型引用清晰、解析顺序确定、生成结果可预测。

一个 IDL 项目由以下两类核心组成部分构成：

1. **meta.json**
   项目的元信息配置文件，用于描述项目的基本属性，是项目级别的必需文件。
2. **IDL 文件（`.idl`）**
   用于定义数据结构、枚举、错误码以及 RPC 接口的语法文件，项目中至少需要包含一个。

典型的项目目录结构如下所示：

```
project/
├── meta.json           # 项目元信息配置文件（必需）
├── service.idl         # 服务接口定义（RPC / SSE）
├── user.idl            # 用户相关的类型与接口定义
├── common.idl          # 通用结构体、枚举、基础类型定义
└── error.idl           # 错误码与错误相关枚举定义
```

### 目录结构说明

* **项目根目录**
  作为 IDL 项目的入口目录，解析器将以该目录作为扫描起点。
* **meta.json**
  必须位于根目录，用于描述项目级元信息，缺失该文件将导致项目无法被识别为合法 IDL 项目。
* **IDL 文件**
  所有 `.idl` 文件处于同一逻辑命名空间中，可以相互引用类型、枚举和常量。
  文件之间不存在显式的 import 关系，其解析顺序由工具统一管理。

在实际使用中，建议按照**功能或领域维度**对 IDL 文件进行拆分，
以提高可读性和长期维护性，但拆分并不会引入额外的命名空间或作用域。

### meta.json 配置文件

**meta.json** 是 IDL 项目的核心元数据描述文件，
用于声明项目的全局属性以及代码生成和工具链所需的基础信息。

该文件必须存在于项目根目录中，
且其内容必须符合 JSON 语法规范，否则项目将无法被正确解析。

meta.json 文件的内容格式示例如下：

```json
{
  "name": "my-service",
  "version": "1.0.0",
  "description": "My service description"
}
```

#### 字段说明

* **`name`**
  项目名称，通常用于生成代码时的包名、模块名或命名空间标识。
  建议使用**语义明确的服务名称**，并遵循统一的命名规范。
* **`version`**
  项目版本号，用于标识 IDL 定义的演进状态。
  该字段可用于代码生成结果的版本区分，以及后续接口兼容性管理。
* **`description`**
  项目的简要说明，用于描述该 IDL 项目的业务背景或主要用途，
  通常会被用于生成文档或接口说明。

meta.json 中声明的信息属于**项目级别元数据**，
不会直接参与接口或数据结构的定义，
但会对工具行为和生成结果产生全局影响。

### IDL 文件

IDL 文件以 `.idl` 作为扩展名，是用于描述**数据模型、枚举定义以及服务接口契约**的核心语法文件。
一个 gs-http-gen IDL 项目可以包含多个 IDL 文件，用于按照功能或领域对接口定义进行拆分和组织。

在同一个项目中：

* 所有 IDL 文件共同组成一个**逻辑整体**；
* 文件之间不存在显式的导入或依赖声明；
* 各文件中的定义在语义上处于同一作用域，可相互引用和组合使用。

这种设计方式旨在降低接口定义的拆分成本，
避免因模块化过度而引入额外的命名空间管理复杂度，
同时确保工具在解析和代码生成阶段能够获得完整、统一的类型信息。

#### 命名空间与类型引用

gs-http-gen IDL 采用**全局命名空间模型**，其规则如下：

* 项目内的所有 IDL 文件共享同一个全局命名空间；
* 在任意 IDL 文件中定义的类型、枚举或常量，
  都可以在同一项目内的其他 IDL 文件中被直接引用；
* 类型名称在项目范围内必须保持唯一，
  不允许在不同 IDL 文件中定义同名的类型、枚举或常量。

该模型简化了类型引用语法，避免引入类似包名或前缀的冗余声明，
但同时也对命名规范提出了更高要求。
因此，在大型项目中应特别注意类型命名的清晰性和一致性，
以避免潜在的命名冲突。

#### 文件组织建议

尽管 IDL 文件之间可以自由相互引用，
但为了提升整体可读性、可维护性以及团队协作效率，
仍然强烈建议按照**功能或业务领域**对 IDL 文件进行合理拆分。

常见且推荐的组织方式包括：

* **通用类型文件**
  用于定义在多个模块之间共享的基础结构体、通用枚举和公共常量，
  例如分页结构、通用响应结构、基础状态枚举等。

* **业务模块文件**
  按照具体业务领域进行划分，
  例如用户模块、订单模块、权限模块等，
  每个文件聚焦于某一业务子域内的类型和接口定义。

* **服务接口文件**
  用于集中定义 RPC 接口（包括普通接口和 SSE 流式接口），
  并配套声明对应的请求和响应类型，
  便于快速了解服务对外暴露的接口能力。

* **错误码文件**
  专门用于维护项目中的错误码枚举及其扩展定义，
  以统一错误语义、避免错误码重复或语义不一致的问题。

合理的文件拆分不会影响语法或生成结果，
但能够显著降低长期维护和扩展时的认知成本。

## IDL 文件构成

一个 IDL 文件由若干语法元素按照约定顺序组合而成，
用于完整描述数据结构定义和服务接口规范。
在逻辑上，一个 IDL 文件通常包含以下几个主要部分：

* **注释**
  用于对类型、字段或接口进行说明，
  注释内容主要面向开发者和文档生成工具，不参与语义解析。

* **关键字**
  IDL 语言内置的保留字，用于声明常量、枚举、类型和接口等语法结构，
  关键字不能被用作标识符名称。

* **常量定义**
  用于定义在整个项目中共享的不可变常量值，
  常用于表达固定配置、阈值或全局开关。

* **枚举定义**
  用于声明一组离散且有限的取值集合，
  常用于状态、分类、选项以及错误码等场景。

* **类型定义**
  用于定义结构体、泛型结构体或联合类型（oneof），
  是描述请求参数、响应数据和领域模型的核心组成部分。

* **RPC 接口定义**
  用于声明对外暴露的服务接口，
  支持普通请求/响应模式以及 SSE 等流式接口形式，
  并可通过注解补充 HTTP 路由、参数绑定和超时等信息。

在语法层面：

* 每一条语句以**换行符**作为分隔；
* 连续的空行将被解析器忽略，仅用于提升可读性；
* 不同语法元素之间不强制要求固定顺序，但建议按照上述逻辑结构进行组织，
  以增强文件的可读性和一致性。

## IDL 语法规则

本章节用于描述 gs-http-gen IDL 的基础语法约定与书写规范。
这些规则构成了所有 IDL 文件的通用语法基础，
用于确保不同项目、不同团队以及不同代码生成器之间具备一致的解析与理解方式。

### 注释

IDL 支持单行注释和多行注释两种形式，用于对类型、字段、接口及业务语义进行说明。
注释仅用于文档和可读性目的，不参与语义解析和代码生成逻辑。

* **单行注释**
  以 `//` 或 `#` 作为行首标记，该行后续内容均视为注释。

* **多行注释**
  使用 `/*` 与 `*/` 包裹，可跨越多行，适用于较长的说明性文本。

示例：

```idl
// 这是单行注释
# 这也是单行注释

/*
 * 这是多行注释
 * 可用于描述复杂的业务背景
 */
```

### 关键字

以下列出的标识符为 gs-http-gen IDL 的**保留关键字**，
用于描述语言的核心语义结构。
保留关键字在任何上下文中均**不得作为类型名、字段名、方法名或其他标识符使用**。

* `extends`
  用于对错误码枚举进行扩展定义。
* `const`
  用于定义常量。
* `enum`
  用于定义枚举类型。
* `type`
  用于定义结构体类型或类型别名。
* `oneof`
  用于定义联合类型（互斥字段集合）。
* `rpc`
  用于定义普通 RPC 接口。
* `sse`
  用于定义基于 Server-Sent Events 的流式接口。
* `true` / `false`
  布尔字面量关键字。
* `optional`
  用于显式标记字段为可选字段。
* `required`
  用于显式标记字段为必填字段。

在语法解析阶段，如检测到用户定义的标识符与上述关键字冲突，
解析器应直接报错并终止处理。

### 标识符

标识符用于为常量、枚举、类型、字段以及接口方法命名，
其命名规则如下：

* 必须以字母（`a-z` 或 `A-Z`）开头；
* 后续字符可以包含字母、数字、下划线 `_` 和点号 `.`；
* 区分大小写，即 `User` 与 `user` 视为不同标识符；
* 标识符不得与任何保留关键字冲突。

为提升可读性和一致性，推荐遵循以下命名约定：

* **常量名**：全部使用大写字母，单词之间使用下划线分隔
  例如：`MAX_SIZE`、`DEFAULT_TIMEOUT`
* **枚举名**：使用大驼峰（PascalCase）命名
  例如：`Status`、`UserType`
* **枚举字段**：全部使用大写字母
  例如：`ACTIVE`、`DISABLED`
* **类型名**：使用大驼峰命名
  例如：`User`、`CreateUserRequest`
* **方法名**：使用大驼峰命名，体现动作语义
  例如：`GetUser`、`UpdateProfile`

上述命名约定为**推荐规范**，
不会影响语法解析，但有助于保持项目风格统一，
并提升生成代码的可维护性。

### 格式与布局规则

为确保 IDL 文件在不同环境和编辑器中具备一致的可读性，
gs-http-gen 对格式和布局提出以下约定：

* **缩进**
  使用 **4 个空格** 作为缩进单位，避免使用 Tab 键。
* **换行**
  每条语句应独占一行，语句之间以换行符分隔。
* **空行**
  允许并推荐使用空行分隔不同的逻辑块，
  以提升结构层次的清晰度。
* **大括号 `{}` 布局规则**

    * 左大括号 `{` 紧跟在定义语句末尾，不单独换行；
    * 右大括号 `}` 必须独占一行，并与对应定义保持相同缩进层级。

示例：

```idl
type User {
    required string id
    string name
    int age
}
```

遵循统一的格式与布局规范，有助于减少无意义的代码差异，
并为后续的自动化格式化、代码生成和差异比对提供稳定基础。

### 基础类型

gs-http-gen 内置了一组基础类型，用于描述最常见的数据表达形式。
这些类型在语义上保持语言无关性，但在代码生成阶段会映射到目标语言中的具体类型。

* **`bool`**
  布尔类型，仅支持两个取值：`true` 和 `false`，通常用于表示开关状态或条件结果。

* **`int`**
  整数类型，用于表示不带小数的数值。
  在默认的 Go 语言代码生成规则中，`int` 会被映射为 `int64` 类型，以满足大多数后端场景下的数值范围需求。
  如果需要使用其他整数类型（如 `int32`、`uint64` 等），可以通过字段级的 `go.type` 注解进行显式指定。

* **`float`**
  浮点数类型，用于表示带小数的数值。
  默认映射为 Go 的 `float64` 类型，以保证精度和通用性。
  同样可以通过 `go.type` 注解，将其映射为其他浮点类型（如 `float32`）。

* **`string`**
  字符串类型，用于表示文本数据。
  **仅支持使用双引号（`"`）定义字符串字面量**，不支持单引号。
  这一限制是为了避免与 `validate` 表达式中使用的单引号字符串产生语法歧义。

* **`bytes`**
  字节数组类型，用于表示二进制数据。
  在序列化（如 JSON 编码）时，`bytes` 类型会以 **Base64 编码后的字符串形式**进行传输，
  以确保在文本协议中的安全性和兼容性。

### 字面量

字面量用于在 IDL 中直接表示常量值，常见于常量定义、注解参数以及验证表达式中。
gs-http-gen 支持以下几类字面量形式：

* **整数**
  支持十进制和十六进制表示形式，例如：
  `42`、`-17`、`0x1A2B`

* **浮点数**
  支持常见的浮点数表示方式，包括科学计数法，例如：
  `3.14`、`.5`、`-2.7e10`

* **字符串**
  使用双引号（`"`）包围的字符串字面量，支持转义字符，例如：
  `"hello"`、`"escaped \" quote"`
  **注意：IDL 本身不支持使用单引号定义字符串字面量。**

* **布尔值**
  布尔字面量仅支持以下两种形式：
  `true`、`false`

* **标识符**
  标识符通常用于在注解中引用枚举成员或其他已定义的符号，
  其具体含义由使用场景和注解语义决定。

### 容器类型

为了表达集合类数据结构，gs-http-gen 提供了两种通用的容器类型，
用于描述列表和键值映射关系。

* **`map<K, V>`**
  映射类型，用于表示键值对集合。

    * 键类型 `K` **必须是 `int` 或 `string`**；
    * 值类型 `V` 可以是任意基础类型、自定义类型或其他容器类型。

* **`list<T>`**
  列表类型，用于表示有序集合。
  元素类型 `T` 可以是任意基础类型、自定义类型或容器类型。

`map` 与 `list` 均支持任意层级的嵌套，
可用于构建复杂的数据结构，例如多级分组、树形结构或聚合结果。

示例如下：

```idl
list<string> tags                     // 字符串列表
list<User> users                      // 用户对象列表
map<string, int> scores               // 字符串到整数的映射
map<int, User> userById               // 整数 ID 到用户对象的映射
list<map<string, User>> groups        // 用户组列表（每个元素是一个用户映射）
map<string, list<User>> usersByDept   // 按部门分组的用户列表映射
```

在代码生成阶段，这些容器类型会被映射为目标语言中对应的集合类型，
同时保持其嵌套结构和类型约束不变。

## 语法详细说明

### 1. 常量

常量用于定义在整个 IDL 项目中保持不变的固定值，
通常用于表达**全局配置、阈值、开关量或约定性数值**。

使用 `const` 关键字来定义常量。当前版本的 IDL 语言中，
常量的类型仅支持以下四种基础类型之一：

* `bool`：布尔类型
* `int`：整数类型
* `float`：浮点数类型
* `string`：字符串类型

示例如下：

```idl
const string APP_NAME = "MyApp"
const int MAX_SIZE = 100
const float PI = 3.14159
const bool DEBUG = true
```

#### 1.1 语法规则

常量定义遵循如下统一语法形式：

```
const <基础类型> <标识符名称> = <常量值>
```

其中：

* `<基础类型>` 必须为 `bool`、`int`、`float` 或 `string` 之一；
* `<标识符名称>` 必须符合标识符命名规则，且在整个项目中唯一；
* `<常量值>` 的类型必须与声明的基础类型严格一致。

#### 1.2 语义约束

* 常量在编译期确定，其值在运行时不可变；
* 常量仅用于表达**基础字面量值**，不参与复杂类型推导；
* 常量的值**不能是枚举类型或复合类型**，也不能引用其他常量。

**注意**：
虽然从表达能力上看，枚举值在某些场景下可以充当“常量”，
但在 IDL 设计中，枚举与常量承担不同语义角色，
因此不允许将枚举成员作为常量值使用，通常也没有实际必要。

### 2. 注解（Annotations）

注解（Annotations）是 IDL 语言中用于补充语义信息的重要机制，
主要用于为**枚举项、字段、类型以及 RPC 接口**附加元数据。

通过注解，可以在不影响核心数据结构定义的前提下，
对生成代码和运行时行为进行精细化控制，例如：

* 指定序列化与反序列化规则；
* 声明字段与 HTTP 路径、查询参数之间的绑定关系；
* 定义字段级或接口级的校验规则；
* 描述接口的路由信息、超时时间或语言相关映射细节。

注解本身不直接参与业务逻辑，
而是作为**工具链和代码生成阶段的重要输入**。

#### 2.1 注解的定义形式

IDL 支持**单行注解**和**多行注解**两种书写形式，
以适应不同复杂度的使用场景。

##### 单行定义

单行注解主要用于字段级场景，
适合注解数量较少、表达较为简单的情况。

其基本格式为：

```
(注解名 = 注解值, 注解名 = 注解值, ...)
```

示例：

```idl
int age (json="age", go.type="int32")
```

##### 多行定义

多行注解适用于注解数量较多或需要提升可读性的场景，
可用于字段、类型以及 RPC 接口定义中。

字段级多行注解使用**小括号**包围，
每个注解可以单独占一行：

```idl
type User {
    string name (
        json = "name"
        go.type = "string"
    )
    int age (json="age,non-omitempty")
}
```

接口级注解必须采用多行定义形式，
并使用**大括号**进行包围：

```idl
rpc GetUser (GetUserRequest) GetUserResponse {
    method = "GET"
    path = "/user/:id"
}
```

#### 2.2 注解语法细节

注解在语法层面遵循以下统一规则：

* **完整语法形式**
  每个注解的完整语法为：

  ```
  <标识符>(=<常量值>)?
  ```

* **注解值类型**
  注解的值必须是可在编译期确定的字面量，其类型可以为：

    * 布尔值
    * 整数
    * 浮点数
    * 字符串
    * 标识符（通常用于引用枚举成员）

* **分隔方式**
  多个注解之间可以使用以下方式分隔：

    * 逗号（`,`）
    * 换行符

  在多行定义中，推荐每行仅声明一个注解，以提升可读性。

* **无值注解（标志型注解）**
  注解可以仅包含标识符而不指定显式值，例如：

  ```
  (enum_as_string)
  ```

  此类注解在语义上等价于布尔值 `true`，
  通常用于表达开关型或特性启用类语义。

### 3. 枚举

枚举类型用于定义一组**离散且有限的取值集合**，常用于表示状态、类型、分类以及错误码等场景。
在 gs-http-gen IDL 中，枚举通过 `enum` 关键字进行定义。

每一个枚举项都必须显式指定一个**整数值**，该值在序列化、反序列化以及跨语言代码生成过程中具有稳定且唯一的语义。

#### 基本定义格式

枚举的基本定义语法如下：

```
enum <枚举名> {
    <枚举项名> = <整数值>
    <枚举项名> = <整数值>
    ...
}
```

* 枚举名在项目中必须唯一；
* 枚举项名在同一个枚举中必须唯一；
* 枚举项的整数值必须为显式指定的常量值，且不得重复。

#### 示例

```
enum Color {
    RED = 1 (desc="红色")
    GREEN = 2 (desc="绿色")
    BLUE = 3 (desc="蓝色")
}
```

在上述示例中：

* `Color` 是枚举类型名称；
* `RED`、`GREEN`、`BLUE` 是枚举项名称；
* 每个枚举项通过 `desc` 注解补充其语义说明，用于提升可读性和生成文档的友好性。

#### 3.1 错误码枚举

错误码枚举是一类**具有特殊语义约束的枚举类型**，用于统一定义接口返回中的错误码及其对应的错误信息。

要定义一个错误码枚举，必须满足以下条件：

* 枚举项必须表示错误码含义；
* 每个枚举项必须携带 `errmsg` 注解；
* `errmsg` 注解用于描述该错误码对应的可读错误信息。

##### 示例

```
enum ErrCode {
    ERR_OK = 0 (errmsg="成功")
    PARAM_ERROR = 1003 (errmsg="参数错误")
    NOT_FOUND = 404 (errmsg="资源未找到")
}
```

在该示例中：

* `ErrCode` 被识别为错误码枚举；
* 每个枚举项均通过 `errmsg` 注解声明对应的错误消息；
* 错误码的整数值通常具有业务或协议层面的含义（如 HTTP 状态码、业务错误段位等）。

在代码生成阶段，工具将基于 `errmsg` 注解：

* 为错误码生成可读的错误信息映射；
* 支持在运行时将错误码自动转换为对应的错误描述。

**注意：**

* 普通枚举（如状态枚举、分类枚举等）应使用 `desc` 注解描述枚举项含义；
* 错误码枚举必须使用 `errmsg` 注解，且不应使用 `desc` 代替；
* 是否为错误码枚举，通常由枚举项是否包含 `errmsg` 注解决定。

#### 3.2 错误码扩展

在大型系统或多模块项目中，错误码往往需要按模块进行拆分和扩展。
为此，gs-http-gen IDL 提供了通过 `extends` 关键字对错误码枚举进行扩展的能力。

通过错误码扩展机制，可以在不修改原有错误码定义的前提下，
为既有错误码集合追加新的错误码项。

##### 示例

```
// 基础错误码定义
enum ErrCode {
    ERR_OK = 0 (errmsg="成功")
    PARAM_ERROR = 1003 (errmsg="参数错误")
}

// 扩展错误码定义
enum extends ErrCode {
    USER_NOT_FOUND = 404 (errmsg="用户未找到")
    PERMISSION_DENIED = 403 (errmsg="权限不足")
}
```

在上述示例中：

* 第一个 `ErrCode` 定义了基础错误码集合；
* 第二个枚举通过 `enum extends ErrCode` 的形式，对 `ErrCode` 进行扩展；
* 扩展后的错误码在逻辑上仍然属于同一个错误码集合。

##### 错误码扩展规则

在使用错误码扩展时，必须遵循以下约束：

1. **被扩展的错误码枚举必须已定义**
   扩展目标必须在当前项目中事先声明，否则将导致解析错误。
2. **扩展的错误码项不得与已有项冲突**
   包括枚举项名称和对应的整数值，均不得重复。
3. **错误码值应保持单调递增或按约定分段**
   建议按照模块、子系统或业务域分配错误码区间，
   避免出现数值回退或混乱分配的情况。

通过 `extends` 机制，可以有效支持错误码的模块化管理，
同时保持错误码体系在全局范围内的一致性和可扩展性。

#### 3.3 `enum_as_string` 特性

当结构体字段的类型为枚举（`enum`）时，默认情况下枚举值在序列化和反序列化过程中以其**整数值**进行表示。
通过为字段添加 `enum_as_string` 注解，可以显式指定该枚举字段在序列化时使用**枚举成员名称的字符串形式**，
并在反序列化时将字符串值自动映射回对应的枚举成员。

该特性用于在保持枚举强类型语义的同时，提高接口数据的**可读性、可维护性和跨系统兼容性**。

**示例：**

```idl
enum Department {
    ENGINEERING = 1 (desc="工程技术部")
    MARKETING = 2 (desc="市场部")
    SALES = 3 (desc="销售部")
}

type Manager {
    string name
    Department dept (enum_as_string)  // 枚举字段以字符串形式进行序列化
}
```

在上述示例中：

* `Department` 是一个以整数值作为内部表示的枚举类型；
* `dept` 字段通过 `enum_as_string` 注解声明其序列化行为发生改变。

在 JSON 序列化结果中，`dept` 字段将输出为枚举成员名称对应的字符串值，例如：

```json
{
  "name": "Alice",
  "dept": "ENGINEERING"
}
```

而非默认的整数形式：

```json
{
  "name": "Alice",
  "dept": 1
}
```

在反序列化过程中，框架将自动根据字符串值（如 `"ENGINEERING"`）
解析并还原为对应的枚举成员，从而保证数据在接口传输与程序内部表示之间的一致性。

`enum_as_string` 特性尤其适用于以下场景：

* **前后端交互**：前端通常更倾向于使用具备业务语义的字符串枚举值，而非难以理解的数字；
* **对外 API 集成**：在面向第三方系统或开放 API 时，字符串形式的枚举值更加稳定且易于演进；
* **调试与日志分析**：字符串枚举在日志和抓包分析中具有更高的可读性。

需要注意的是，`enum_as_string` 仅影响字段在**序列化与反序列化阶段的表示形式**，
不会改变枚举在类型系统中的定义方式，也不会影响枚举成员的整数取值及其内部语义。

### 4. 类型

类型（Type）用于描述接口请求、响应以及领域模型中的数据结构，是 IDL 中最核心的组成部分之一。
类型定义使用 `type` 关键字，用于声明一个可被复用的数据结构或类型别名。

gs-http-gen IDL 当前支持以下三种主要的类型定义方式：

1. 普通结构体
2. 泛型结构体
3. 泛型实例化（基于泛型结构体的具体类型定义）

#### 4.1 普通结构体

普通结构体是最基础、也是最常见的类型定义方式，
用于描述由多个字段组成的复合数据类型。

其基本语法格式如下：

```
type <类型名> {
    <字段定义>
}
```

示例：

```
type User {
    required string name       // 必填字段，不能为空
    int age                    // 可选字段，默认可省略
    optional string email      // 显式声明为可选字段
    list<string> tags          // 字符串列表
}
```

在普通结构体中：

* 每一行定义一个字段；
* 字段由 **修饰符（可选） + 类型 + 字段名** 组成；
* 字段可以附加注释或注解，用于补充说明或控制生成行为；
* 字段之间通过换行进行分隔，不需要使用分号。

普通结构体通常用于定义：

* RPC 请求和响应的数据结构；
* 业务领域中的实体对象；
* 通用的数据承载结构。

#### 4.2 泛型结构体

为提升类型定义的复用能力，IDL 语言支持**有限形式的泛型结构体**定义。
泛型结构体通常用于表达具有固定结构、但内部数据类型可变的通用返回值或包装类型。

泛型结构体的定义语法如下：

```
type <类型名><<泛型参数>> {
    <字段定义>
}
```

示例：

```
type Response<T> {
    int code              // 返回码
    string message        // 返回消息
    T data                // 泛型数据，类型由实例化时决定
}
```

在泛型结构体中：

* 泛型参数通过尖括号 `< >` 声明；
* 泛型参数本身不是具体类型，仅作为占位符存在；
* 泛型参数只能在当前类型的字段定义中使用；
* 泛型结构体**本身不能直接作为字段类型使用**，必须先进行实例化。

泛型结构体常用于定义：

* 统一的响应包装结构（如 `Response<T>`、`Result<T>` 等）；
* 需要在不同接口中复用、但内部数据类型不同的通用模型。

#### 4.3 泛型实例化

对于已定义的泛型结构体，可以通过**泛型实例化**的方式，将其转换为一个具体类型。
实例化的过程即：使用具体类型替换泛型参数，从而得到一个可直接使用的类型定义。

泛型实例化的基本语法格式为：

```
type <新类型名> <已定义的泛型类型名><<具体类型>>
```

示例：

```
type UserResponse Response<User>  // 将 Response<T> 实例化为 Response<User>
```

在上述示例中：

* `Response<User>` 表示使用 `User` 类型替换泛型参数 `T`；
* `UserResponse` 是实例化后得到的新类型名；
* 实例化后的类型在语义上等价于一个普通结构体，可在字段、RPC 定义中直接使用。

需要注意的是：

* 泛型实例化仅用于生成**具体类型定义**，不会引入新的泛型参数；
* 实例化后的类型与普通结构体在使用层面完全一致；
* 一个泛型结构体可以被实例化多次，生成多个不同的具体类型。

泛型实例化机制能够在保持接口定义简洁一致的同时，
避免重复定义结构相同但数据类型不同的响应或包装类型。

#### 4.4 结构体字段

结构体字段用于描述类型中所包含的数据成员，是 IDL 中最核心的组成元素之一。
字段定义不仅决定了数据的结构形态，也直接影响序列化结果、参数校验逻辑以及生成代码的类型表现。

根据字段的类型表达能力与使用场景，结构体字段主要分为以下几类：

* **普通字段**：使用具体类型定义的字段，是最常见的字段形式；
* **泛型字段**：在泛型结构体中使用类型参数作为字段类型，用于增强结构体的通用性与复用能力；
* **带注解的字段**：在字段定义的基础上，通过注解补充序列化、校验或绑定等元信息。

不同类型的字段在语法规则、使用限制以及生成代码的表现上存在差异，
需要在定义时严格遵循相应的约束。

**4.4.1 普通字段**

普通字段是指使用明确、具体类型定义的结构体字段，
其类型可以是基础类型、枚举类型、结构体类型或容器类型。

普通字段的基本定义格式如下：

```
<修饰符> <类型> <字段名>
```

其中：

* **修饰符**用于描述字段在数据传输和解析过程中的必选性；
* **类型**用于指定字段的数据类型；
* **字段名**用于标识字段在结构体中的名称。

##### 修饰符说明

* **`required`**
  表示该字段为必填字段，在数据传输时必须提供。
  若请求或响应中缺失该字段，或字段值为空，
  则在解析或校验阶段应视为非法数据并返回错误。

* **`optional`**
  表示该字段为可选字段，在数据传输时可以省略。
  当字段未提供时，系统会将其视为缺省状态，
  并在生成的代码中通常表现为可空类型或零值。

如果字段未显式声明修饰符，则默认视为 **可选字段**，
其行为与使用 `optional` 修饰符保持一致。

##### 示例

```
type User {
    required string name   // 必填字段，必须提供
    int age                // 可选字段，未显式声明修饰符
    optional string email  // 显式声明为可选字段
}
```

在上述示例中：

* `name` 字段为必填字段，缺失将导致校验失败；
* `age` 字段未声明修饰符，默认作为可选字段处理；
* `email` 字段通过 `optional` 显式声明为可选字段，用于增强语义可读性。

##### 类型使用限制说明

普通字段的类型必须是**已确定的具体类型**，不允许直接使用未实例化的泛型类型。

需要注意的是：

* 字段类型 **不能直接使用泛型参数**（如 `T`），
  除非该字段位于泛型结构体内部；
* 对于非泛型结构体，字段类型只能是：

    * 基础类型（如 `int`、`string` 等）
    * 枚举类型
    * 已定义的结构体类型
    * 已实例化的泛型类型
* **仅容器类型**（`list<T>` 和 `map<K, V>`）
  允许在字段定义中直接使用泛型参数作为元素类型或值类型。

**4.4.2 泛型字段**

泛型字段是指在**泛型结构体**中，
使用泛型类型参数作为字段类型的字段。

通过引入泛型字段，可以在不牺牲类型安全的前提下，
显著提升结构体定义的灵活性和复用能力，
常用于表示通用返回结果、包装类型或中间数据结构。

泛型字段只能出现在**带有泛型参数的结构体定义中**，
且其类型必须是当前结构体声明的泛型参数之一。

##### 示例

```
type Result<T> {
    bool success    // 普通字段
    T data          // 泛型字段，类型由实例化时确定
    string message  // 普通字段
}
```

在上述示例中：

* `Result` 是一个带有泛型参数 `T` 的结构体；
* `data` 字段使用 `T` 作为类型，其具体类型将在泛型实例化时确定；
* 当 `Result<T>` 被实例化为 `Result<User>` 时，
  `data` 字段的实际类型即为 `User`。

泛型字段使得同一结构体定义能够适配多种不同的数据类型，
同时保持结构和语义的一致性，是 IDL 中实现抽象与复用的重要机制之一。

### 4.4.3 字段注解

字段注解（Field Annotations）用于为结构体字段补充**元数据信息**，
以控制代码生成、序列化行为、参数绑定方式以及运行时校验逻辑。

通过字段注解，可以在不改变字段类型本身的前提下，
对字段的**表示形式、使用约束和兼容策略**进行精细化描述。
这些注解在代码生成阶段会被解析，并映射为对应语言或框架中的具体实现细节。

字段注解以小括号 `()` 包裹，紧跟在字段定义之后。
同一个字段可以同时声明多个注解，多个注解之间可以使用逗号或换行符分隔。

常用的字段注解可以按照功能划分为以下几类。

#### 自定义类型注解

自定义类型注解用于指定字段在目标语言中的具体类型表示，
以满足精度、性能或与既有代码兼容的需求。

* **`go.type`**
  指定该字段在 Go 语言中的具体类型。
  例如，`go.type="int32"` 表示在生成的 Go 代码中，
  该字段将使用 `int32` 类型，而非默认映射类型。

示例：

```
int age (go.type="int32")
```

#### 序列化注解

序列化注解用于控制字段在序列化和反序列化过程中的行为，
主要影响 JSON 等数据格式的字段名称和输出规则。

* **`json`**
  指定字段在 JSON 序列化时使用的字段名及附加选项。
  例如，`json="name"` 会将字段序列化为 `name`，
  而 `json="desc,non-omitempty"` 则表示即使字段为空值，
  也会强制输出到序列化结果中。

* **`enum_as_string`**
  用于枚举类型字段，表示在序列化和反序列化时，
  使用枚举项的字符串名称，而不是对应的整数值。
  该注解在与前端或第三方接口交互时尤为常见。

示例：

```
string description (json="desc,non-omitempty")
Department dept (enum_as_string)
```

#### 参数绑定注解

参数绑定注解用于将结构体字段与 HTTP 请求中的参数来源进行绑定，
通常用于 RPC 请求类型中。

* **`path`**
  将字段绑定到 RESTful 路径中的路径参数。
  例如，`path="id"` 表示该字段对应路径中的 `:id` 或 `{id}` 参数。

* **`query`**
  将字段绑定到 HTTP 查询参数。
  例如，`query="locale"` 表示该字段对应请求中的 `?locale=xx` 参数。

这些注解通常用于请求结构体中，
并与 RPC 接口定义中的路径规则配合使用。

示例：

```
string userId (path="id")
string locale (query="locale")
```

#### 验证注解

验证注解用于为字段声明运行时校验规则，
以确保字段值在请求处理或数据解析阶段满足预期约束。

* **`validate`**
  指定字段的验证规则，其值为一个逻辑表达式。
  表达式中可以使用内置函数、比较运算符以及特殊变量 `$`
  来引用当前字段的值。

验证规则会在运行时自动执行，
当校验失败时，通常会返回对应的参数错误。

示例：

```
string email (validate="email($)")
int age (validate="$ >= 0 && $ <= 150")
```

#### 其他注解

* **`deprecated`**
  标记该字段已被弃用。
  被标记为弃用的字段在生成代码或文档时，
  通常会附带弃用提示，用于引导开发者避免继续使用该字段。

* **`compat_default`**
  为字段指定兼容性默认值。
  当字段在请求或数据中缺失时，
  系统将自动使用该默认值进行填充，
  以确保新旧版本之间的兼容性。

示例：

```
string oldField (deprecated="true")
int pageSize (compat_default="20")
```

#### 综合示例

```
type User {
    string name (go.type="string")  
    int age (json="age", go.type="int32")  
    string description (json="desc,non-omitempty")  
    string email (validate="email($)", deprecated="true")  
    string userId (path="id")  
    string locale (query="locale")  
}
```

在上述示例中，字段注解分别用于：

* 指定目标语言中的具体类型；
* 控制 JSON 序列化行为；
* 声明参数绑定关系；
* 添加字段级校验规则；
* 标记字段弃用状态。

通过合理使用字段注解，可以在 IDL 层面集中表达接口约束和行为规则，
从而显著降低实现层的重复编码和隐式约定成本。

#### 4.5 嵌入类型（Embedded Type）

在结构体定义中，IDL 允许将**已定义的其他结构体类型**作为嵌入类型直接引入。
嵌入类型主要用于**复用字段定义**、**消除重复结构声明**，以及在保持数据模型扁平化的同时，
提升类型定义的表达能力与可维护性。

当一个类型被作为嵌入类型使用时，其内部声明的所有字段，
会在代码生成阶段**自动展开并合并**到当前结构体中。
嵌入类型本身不会作为一个独立的字段存在，
也不会在序列化结果中引入额外的层级结构。

##### 基本示例

```idl
type Address {
    string street
    string city
}

type Person {
    Address          // 嵌入 Address 类型，无字段名
    string name
}
```

在上述示例中，`Address` 被作为嵌入类型引入到 `Person` 中。
由于未为 `Address` 指定字段名，其所有字段将被直接合并到 `Person` 结构体中。

在代码生成阶段，`Person` 类型将包含 `Address` 中声明的全部字段，
且不会存在名为 `Address` 的中间字段。
生成后的结构体示意如下：

```
type Person struct {
    street string // 来自 Address 类型
    city   string // 来自 Address 类型
    name   string
}
```

从语义上看，`Person` 拥有 `street`、`city` 和 `name` 三个同级字段，
而 `Address` 仅作为字段集合的复用来源存在。

##### 设计说明

嵌入类型的设计目的在于：

* 避免在多个结构体中重复声明相同的字段集合；
* 保持生成代码与序列化结构的扁平化，减少嵌套层级；
* 提高类型定义的可读性和一致性；
* 与主流语言（如 Go）的匿名嵌入结构体语义保持一致。

需要注意的是，嵌入类型是一种**编译期结构展开机制**，
而非运行时的组合或继承关系。

##### 嵌入类型合并规则

嵌入类型在使用时必须遵循以下规则：

1. **字段展开规则**
   嵌入类型中声明的所有字段，会在代码生成时被直接合并到当前结构体中，
   并与当前结构体中声明的字段处于同一层级。

2. **字段名冲突限制**
   如果嵌入类型中的字段名与当前结构体中已声明的字段名发生冲突，
   或多个嵌入类型之间存在同名字段，将被视为非法定义并导致编译错误。

3. **无独立字段实体**
   嵌入类型本身不会作为一个独立字段存在，
   在语法层面和生成结果中均不会保留嵌入类型的名称。

4. **语法形式约束**
   在结构体定义中声明嵌入类型时，仅需书写类型名，
   不需要也不允许指定字段名或类型声明。

##### 使用建议

* 嵌入类型适用于**字段集合稳定、语义明确**的公共结构体定义；
* 不建议对包含大量可选字段或频繁变更的类型进行嵌入；
* 应避免形成过深或复杂的嵌入链，以保证结构定义的可读性和可预测性。

#### 4.6 联合类型（oneof）

通过 `oneof` 关键字，可以定义**联合类型（Union Type）**。
联合类型用于表示“**同一字段在同一时刻只能取多种候选类型中的一种**”的语义，
适用于需要表达多态数据结构或不同行为分支返回值的场景。

在语义上，`oneof` 类型具有以下核心特征：

* 一个联合类型在任意时刻**只能有一个成员处于激活状态**；
* 各成员类型之间是**互斥关系**，不能同时存在；
* 联合类型本身并不携带业务语义，仅用于表达数据结构上的选择关系。

联合类型的基本定义格式如下：

```idl
oneof <联合类型名> {
    <类型名1>
    <类型名2>
    ...
}
```

示例如下：

```idl
oneof Value {
    User
    Manager
}
```

##### 4.6.1 生成代码结构

在代码生成阶段，`oneof` 联合类型通常会被映射为一个**包含类型标识字段和若干可选字段的结构体**。
以 Go 语言为例，生成的结构体形式通常如下所示：

```
type Value struct {
    FieldType ValueType `json:"FieldType" form:"FieldType"` // 当前激活的类型标识
    User      *User     `json:"User,omitempty" form:"User"` // 联合成员之一
    Manager   *Manager  `json:"Manager,omitempty" form:"Manager"` // 联合成员之一
}
```

其中：

* **`FieldType`**
  是一个由工具自动生成的枚举类型（如 `ValueType`），
  用于显式标识当前联合类型实例中被选中的成员类型；
* **成员字段（如 `User`、`Manager`）**
  均为指针类型或可空类型，用于承载具体的联合成员数据。

##### 4.6.2 序列化与约束规则

在序列化和反序列化过程中，`oneof` 类型需遵循以下约束规则：

1. **唯一性约束**
   在一个联合类型实例中，**必须且只能有一个成员字段被赋值**；
2. **一致性约束**
   `FieldType` 的取值必须与实际被赋值的成员字段保持一致；
3. **序列化行为**

* 仅序列化当前被激活的成员字段；
* 未激活的成员字段在序列化结果中必须被忽略；

4. **非法状态处理**

* 若多个成员字段同时存在；
* 或 `FieldType` 与实际字段不一致；

生成代码应在反序列化或校验阶段明确报错。

通过引入显式的类型标识字段，`oneof` 类型在保持表达能力的同时，
避免了仅通过字段存在性推断类型所带来的歧义，
从而提升了跨语言、跨系统交互时的数据稳定性和可维护性。

#### 4.7 序列化与反序列化

为了正确支持**必选字段、可选字段以及兼容性默认值**等语义，
基于 gs-http-gen IDL 生成的代码在反序列化阶段需要支持**流式解析（Streaming Decode）**能力。

流式解析的核心目标包括：

* 在解析过程中逐字段处理输入数据；
* 在不完整输入的情况下仍能进行结构校验；
* 在解析完成前即可识别必选字段缺失等错误。

##### 4.7.1 字段修饰符语义

在序列化和反序列化过程中，不同字段修饰符具有明确且固定的语义：

* **必选字段（`required`）**

    * 字段在输入数据中必须存在；
    * 字段值不得为 `null` 或语义上的“空值”；
    * 若缺失或非法，解析过程应直接失败。
* **可选字段（`optional`）**

    * 字段在输入数据中可以不存在；
    * 在生成代码中通常映射为可空类型（如指针）；
    * 若字段存在，则仍需参与校验规则（如 `validate`）。
* **默认值字段（`compat_default`）**

    * 当字段在输入数据中缺失时，自动填充预定义的默认值；
    * 该机制主要用于接口演进过程中的向后兼容；
    * 默认值的填充应发生在反序列化阶段，并在校验之前完成。

##### 4.7.2 处理流程说明

典型的反序列化与校验流程如下：

1. **流式解析输入数据**
2. **检测必选字段是否存在**
3. **为缺失字段填充兼容性默认值**
4. **执行字段级与结构级校验**
5. **生成最终结构体实例**

通过上述机制，生成的代码能够在保证严格校验的同时，
兼顾接口演进过程中的兼容性需求，
从而在长期维护的服务体系中保持数据结构的稳定性和可预测性。

### 5. Validate 注解

`validate` 注解用于对字段值或对象状态进行声明式校验，
是 gs-http-gen IDL 中用于**数据合法性约束**的核心机制之一。

通过 `validate` 注解，可以在接口定义阶段提前声明字段的取值范围、格式规则以及逻辑约束，
从而在运行时对输入数据进行统一、可预测的校验，
避免将分散且重复的校验逻辑下沉到各语言实现中。

`validate` 注解支持内置验证函数、自定义验证函数以及由多种操作符组合而成的表达式，
能够满足从简单字段校验到复杂逻辑判断的多种需求。

#### 5.1 验证函数

`validate` 注解内置了一组基础验证函数，用于覆盖常见的校验场景。

目前内置支持的函数包括但不限于：

* **`len(expr)`**
  用于计算表达式结果的长度，适用于字符串、列表（`list`）、映射（`map`）等可计数类型。

  示例：

  ```
  validate="len($) <= 64"
  ```

除内置函数外，用户还可以在 `validate` 表达式中使用**自定义验证函数**。

自定义验证函数需遵循以下规则：

* 函数名不得与任何内置验证函数重名；
* 函数名在同一项目内必须全局唯一；
* 自定义函数可以在多个字段或类型的 `validate` 注解中重复使用；
* 自定义函数的具体实现由代码生成器生成对应的函数模板，
  开发者需在模板中补充实际的校验逻辑。

通过这种方式，IDL 层只负责**声明校验意图**，
而具体实现细节则交由语言侧完成，从而兼顾表达能力与实现灵活性。

#### 5.2 操作符

`validate` 表达式支持一组与主流编程语言语义一致的操作符，
用于构建复杂的逻辑判断条件。

支持的操作符类型包括：

* **比较操作符**
  用于数值或可比较类型之间的大小与等值判断：
  `==`、`!=`、`<`、`<=`、`>`、`>=`

* **逻辑操作符**
  用于组合多个布尔表达式：
  `&&`（逻辑与）、`||`（逻辑或）、`!`（逻辑非）

* **算术操作符**
  用于数值运算：
  `+`、`-`、`*`、`/`

* **函数调用**
  支持调用内置函数或自定义验证函数，例如：
  `len($)`、`email($)`、`regexp($, 'pattern')`

验证表达式遵循标准的运算符优先级规则，
用户可以通过圆括号 `()` 显式指定表达式的计算顺序，
以避免歧义并提升可读性。

**注意**：
在 `validate` 表达式中，字符串字面量**必须使用单引号**（`'`）包围，
而不能使用双引号（`"`）。
该约定用于避免与 IDL 语法中其他字符串定义形式产生歧义。

#### 5.3 表达式语法结构

从语法结构上看，`validate` 表达式由以下基本构成要素组成：

1. **原子表达式**
   包括标识符、字面量（整数、浮点数、字符串、布尔值）以及特殊标识符：

* `$`：表示当前被校验字段的值
* `nil`：表示空值或未设置状态

2. **函数调用表达式**
   形如 `func(arg1, arg2, ...)` 的函数调用，
   其中参数本身也可以是任意合法的表达式。

3. **一元表达式**
   目前仅支持逻辑非操作符 `!`，用于对布尔表达式取反，例如：

   ```
   !($ > 0)
   ```

4. **关系表达式**
   使用关系操作符对两个表达式的大小关系进行判断，
   例如：`$ >= 0`、`len($) < 10`

5. **相等性表达式**
   使用 `==` 或 `!=` 判断两个表达式在语义上的相等或不等。

6. **逻辑与表达式**
   使用 `&&` 连接多个条件，要求所有子条件均为真。

7. **逻辑或表达式**
   使用 `||` 连接多个条件，只要任一子条件为真即可通过校验。

8. **括号表达式**
   使用圆括号 `()` 将子表达式组合为一个整体，
   用于显式控制运算顺序和提升表达式可读性。

#### 5.4 运算符优先级

在未显式使用括号的情况下，`validate` 表达式的运算符优先级从高到低依次为：

1. **最高优先级**

* 原子表达式
* 函数调用
* 括号表达式

2. **一元操作符**

* 逻辑非 `!`

3. **关系操作符**

* `<`、`<=`、`>`、`>=`

4. **相等性操作符**

* `==`、`!=`

5. **最低优先级**

* 逻辑与 `&&`
* 逻辑或 `||`

在编写复杂校验规则时，建议始终通过括号明确表达式结构，
以提高可读性并降低因优先级误解而导致的校验错误风险。

#### 5.3 特殊变量

在 `validate` 表达式中，提供了一组内置的特殊变量，用于在校验逻辑中引用运行时上下文中的数据。

* **`$`**
  表示**当前被校验字段的值**。
  在字段级 `validate` 注解中，`$` 始终指向该字段自身，无论字段的实际类型为何（基础类型、容器类型或自定义类型）。

在编写验证表达式时，通常通过 `\$` 来引用当前字段，并将其作为函数参数或参与逻辑、比较运算。
这使得校验规则可以以声明式方式直接绑定到字段定义本身，从而避免额外的校验代码分散在业务逻辑中。

需要注意的是，`$` 仅在 **字段级校验上下文** 中具有明确含义，
不应被理解为通用的全局变量或对象引用。

#### 5.4 使用示例

以下示例展示了在结构体字段上使用 `validate` 注解定义常见校验规则的方式。
通过组合内置函数、比较操作符以及逻辑运算符，可以表达丰富且可读的校验逻辑。

```idl
type User {
    required string name (validate="$ != '' && len($) <= 64")  // 字段不能为空，且长度不超过 64
    int age (validate="$ >= 0 && $ <= 150")                    // 年龄取值范围为 0 到 150
    string email (validate="email($)")                          // 邮箱格式校验
    list<string> tags (validate="len($) <= 10")                 // 标签数量不超过 10 个
    string phone (validate="phone($)")                          // 手机号格式校验
}
```

在上述示例中：

* 每个字段的校验规则都通过 `validate` 注解直接附加在字段定义上；
* 校验逻辑以字符串表达式的形式声明，在代码生成阶段会被解析并转换为对应语言的校验实现；
* 当字段未提供值且为可选字段时，其校验行为取决于具体实现策略（例如：是否跳过校验或先进行默认值填充）。

### 6. RPC 接口

RPC 接口用于描述服务对外暴露的 API 能力，是 IDL 中连接**数据模型**与**服务行为**的核心组成部分。

gs-http-gen 支持两种类型的 RPC 接口定义：

1. **普通 RPC 接口**
   适用于典型的请求-响应模型，一次请求对应一次完整响应。
2. **SSE（Server-Sent Events）流式接口**
   适用于服务端以流的形式持续向客户端推送数据的场景。

无论是哪种接口形式，RPC 定义均通过声明式方式描述其输入、输出以及 HTTP 相关元信息，
以确保接口行为在设计阶段即可被准确理解和验证。

#### 6.1 普通接口

普通 RPC 接口用于定义标准的同步请求-响应式服务接口，其基本语法格式如下：

```
rpc <接口名> (<请求类型>) <响应类型> {
    <注解定义>
}
```

其中：

* **接口名**
  用于标识该 RPC 方法，通常采用首字母大写的驼峰命名方式。
* **请求类型**
  表示接口的输入参数结构，通常为一个结构体类型。
* **响应类型**
  表示接口的返回结果结构，通常为一个结构体或泛型实例化类型。
* **注解定义**
  用于描述接口的 HTTP 映射规则及其他元信息，例如请求方法、路径、超时配置等。

示例如下：

```idl
rpc GetUser (GetUserRequest) GetUserResponse {
    method = "GET"
    path = "/user/:id"
}
```

在上述示例中：

* `GetUser` 定义了一个名为“获取用户信息”的 RPC 接口；
* 该接口使用 HTTP `GET` 方法；
* 请求路径中包含路径参数 `:id`，用于标识具体的用户资源；
* 请求参数与路径参数的绑定关系由请求类型中的字段注解进行声明。

通过这种方式，接口的输入、输出以及 HTTP 行为均被集中描述在 IDL 中，
从而为代码生成、接口校验和文档生成提供统一、可靠的依据。

#### 6.2 SSE 流式接口

SSE（Server-Sent Events）是一种基于 HTTP 的单向流式通信机制，
允许服务端在一次请求建立后，持续向客户端推送事件数据。
相比传统的请求-响应模型，SSE 更适合用于**实时数据传输、事件通知以及长时间计算结果的渐进式返回**。

在 gs-http-gen IDL 中，SSE 流式接口通过 `sse` 关键字进行声明，
其语法结构与普通 RPC 接口保持一致，但在语义上表示**响应数据以流的形式持续输出**，
而非一次性返回。

SSE 接口的基本定义格式如下：

```
sse <接口名> (<请求类型>) <响应类型> {
    <注解定义>
}
```

其中：

* **接口名**：表示流式接口的逻辑名称；
* **请求类型**：用于描述建立 SSE 连接时所需的请求参数；
* **响应类型**：表示单次事件推送的数据结构类型；
* **注解定义**：用于声明 HTTP 方法、路径及其他与传输行为相关的元信息。

示例定义如下：

```
sse StreamEvents (StreamRequest) Event {
    method = "GET"
    path = "/events"
}
```

在该示例中，客户端通过一次 `GET /events` 请求建立 SSE 连接，
服务端随后将以流的形式持续向客户端推送 `Event` 类型的数据。

SSE 接口特别适用于以下典型场景：

1. **实时数据推送**
   例如行情数据更新、系统监控指标、聊天消息推送等，
   需要在服务端状态变化时即时通知客户端的场景。

2. **长时间计算结果的流式返回**
   特别适用于 AI 推理、内容生成等计算耗时较长的场景，
   服务端可以将中间结果逐步推送给客户端，
   避免长时间阻塞并显著提升用户体验。

需要注意的是，SSE 接口在语义上表示**单向数据流**：
客户端仅负责发起连接请求，数据始终由服务端向客户端推送。

#### 6.3 HTTP 相关注解

在 RPC 与 SSE 接口定义中，
可以通过注解为接口声明具体的 HTTP 行为与传输属性，
包括请求方法、路由路径、内容类型以及超时策略等。

HTTP 相关注解主要用于：

* 将接口定义映射到具体的 HTTP 路由；
* 控制请求与响应的编码方式；
* 指定网络层面的超时与传输行为；
* 为代码生成器和运行时框架提供明确的配置依据。

常见的 HTTP 相关注解包括：

* **`method`**
  指定 HTTP 请求方法，例如 `GET`、`POST`、`PUT`、`DELETE` 等。

* **`path`**
  指定请求路径，支持 RESTful 风格的路径参数定义，
  可结合 `path` 注解在请求类型中进行参数绑定。

* **`contentType`**
  指定请求体的编码方式，常见取值包括：

    * `"json"`：使用 JSON 编码请求体；
    * `"form"`：使用表单（application/x-www-form-urlencoded 或 multipart）编码。

* **`connTimeout`**
  指定建立连接的超时时间，单位为毫秒。

* **`readTimeout`**
  指定读取响应数据的超时时间，单位为毫秒。

* **`writeTimeout`**
  指定写入请求数据的超时时间，单位为毫秒。

* **`resp.go.type`**
  指定 RPC 接口在 Go 语言中生成的响应类型，
  通常用于对返回结构进行更精细的控制或兼容特殊场景。

以下示例展示了一个带有完整 HTTP 注解的普通 RPC 接口定义：

```
rpc GetUser (GetUserRequest) GetUserResponse {
    method = "GET"
    path = "/user/:id"
    contentType = "json"
    connTimeout = "100"
    readTimeout = "300"
    writeTimeout = "300"
    summary = "获取用户信息"
}
```

在该示例中：

* 接口通过 `GET /user/:id` 路由进行访问；
* 请求参数通过路径参数与查询参数进行绑定；
* 请求与响应均采用 JSON 编码；
* 明确声明了连接、读取和写入阶段的超时策略；
* `summary` 注解用于提供接口的简要说明，便于文档生成与接口治理。

通过在 IDL 中集中声明 HTTP 相关注解，
可以有效避免接口行为分散在代码各处定义的问题，
从而提升接口定义的可读性、一致性以及自动化处理能力。

#### 6.4 RESTful 路径规则与参数绑定

RESTful 路径用于描述 HTTP 接口的访问规则，并支持在路径中定义动态参数。
gs-http-gen 在 RPC 接口定义中，对路径参数的声明、匹配方式以及参数绑定规则提供了明确且统一的规范，
以确保路由解析行为在不同语言和运行环境中的一致性。

##### 路径参数风格

gs-http-gen 支持以下两种常见的路径参数声明风格，二者在语义和匹配行为上完全等价，可以混合使用：

1. **冒号风格（Colon Style）**

* 普通参数：`:paramName`
* 通配符参数：`:paramName*`

2. **大括号风格（Brace Style）**

* 普通参数：`{paramName}`
* 通配符参数：`{paramName...}`

路径参数用于在请求路径中声明可变部分，并在请求处理时将对应的路径片段解析并绑定到请求对象的字段中。

##### 路径段类型

在路径定义中，每一个路径段（segment）可以属于以下三种类型之一：

* **静态段（Static Segment）**
  固定不变的路径片段，例如 `users`、`books`、`settings` 等。
  静态段用于明确接口的层级结构和语义含义。

* **普通参数段（Param Segment）**
  形式为 `:id` 或 `{id}`，用于匹配**单个路径段**。
  该参数仅匹配一个不包含 `/` 的连续字符串。

* **通配符参数段（Wildcard Segment）**
  形式为 `:path*` 或 `{path...}`，用于匹配**一个或多个路径段**。
  通配符参数通常位于路径末尾，用于表示不定深度的路径结构，例如文件路径或层级资源。

##### 路径参数命名规则

为保证路径解析的一致性和可读性，路径参数名称必须遵循以下命名规则：

* 参数名必须以字母开头，不能以数字开头；
* 参数名可以包含：

    * 字母（`a-z`, `A-Z`）
    * 数字（`0-9`）
    * 下划线（`_`）
    * 连字符（`-`）
* 参数名区分大小写；

合法示例：

* `:id`
* `:user_id`
* `:user-name`
* `{orgId}`
* `{repo-name}`

##### 路径定义示例

```idl
// 冒号风格路径参数
rpc GetUser (GetUserRequest) GetUserResponse {
    method = "GET"
    path = "/user/:id"          // 普通路径参数 :id
}

rpc GetFile (GetFileRequest) GetFileResponse {
    method = "GET"
    path = "/files/:path*"      // 通配符路径参数 :path*
}

// 大括号风格路径参数
rpc GetUser (GetUserRequest) GetUserResponse {
    method = "GET"
    path = "/user/{id}"         // 普通路径参数 {id}
}

rpc GetFile (GetFileRequest) GetFileResponse {
    method = "GET"
    path = "/files/{path...}"   // 通配符路径参数 {path...}
}

// 混合路径风格示例
rpc ComplexPath (ComplexPathRequest) ComplexPathResponse {
    method = "GET"
    path = "/org/{orgId}/repos/:repoId/branches/{branch...}"  // 混合使用两种风格
}

// 包含多个静态路径段的示例
rpc StaticPath (StaticPathRequest) StaticPathResponse {
    method = "GET"
    path = "/api/v1/users/:id/settings"
}
```

在同一路径中可以同时使用冒号风格和大括号风格的参数声明，
解析器会统一处理，不会因风格差异影响路由匹配结果。

##### 请求参数绑定规则

在定义 RPC 请求类型时，可以通过字段注解将请求结构体中的字段与路径参数或查询参数进行显式绑定，
从而实现路径、查询字符串与请求对象之间的自动映射。

```idl
// 请求类型示例
type GetUserRequest {
    required string userId (path="id")     // 绑定到路径参数 :id 或 {id}
    optional string locale (query="locale") // 绑定到查询参数 ?locale=value
}
```

绑定规则说明如下：

* **路径参数绑定（`path` 注解）**

    * 字段名通过 `path="paramName"` 显式指定绑定的路径参数；
    * 被绑定的字段必须声明为 `required`；
    * 字段类型通常为基础类型（如 `int`、`string`）；
    * 每一个路径参数必须且只能绑定到一个请求字段。

* **查询参数绑定（`query` 注解）**

    * 字段名通过 `query="paramName"` 指定对应的查询参数名称；
    * 查询参数通常声明为 `optional`；
    * 可以为查询参数字段设置默认值或校验规则；
    * 适用于分页参数、过滤条件、排序规则等场景。

##### 约束与注意事项

* 路径中声明的所有参数，必须在请求类型中有对应的字段进行绑定；
* 未被绑定的路径参数将被视为配置错误；
* 通配符路径参数在请求对象中通常映射为字符串类型，包含完整的匹配路径片段；
* 路径参数与查询参数在语义上严格区分，不能混用注解。

通过上述规则，gs-http-gen 能够在接口定义阶段明确路由结构与参数来源，
从而避免隐式约定，提高接口定义的可读性、一致性和可维护性。

## 示例

以下示例展示了一个**典型电商系统**的完整 IDL 定义，涵盖了实际项目中最常见的使用场景，包括：

* 业务状态与错误码的枚举定义
* 泛型响应结构的抽象与复用
* 请求与响应模型的定义
* 普通 RPC 接口与 SSE 流式接口
* 路径参数、查询参数与字段校验规则的综合使用

该示例旨在演示 **gs-http-gen IDL 在真实业务场景下的推荐写法与组织方式**，
同时也可作为新项目的参考模板。

```

// ========================
// 业务状态枚举定义
// ========================
// 用于描述订单或业务流程的处理状态
enum Status {
    PENDING = 1 (desc="待处理")
    COMPLETED = 2 (desc="已完成")
}

// ========================
// 错误码枚举定义
// ========================
// 所有接口统一使用的错误码定义
// errmsg 注解用于为每个错误码提供可读的错误信息
enum ErrCode {
    ERR_OK = 0 (errmsg="success")
    PARAM_ERROR = 1003 (errmsg="parameter error")
    USER_NOT_FOUND = 404 (errmsg="user not found")
}

// ========================
// 通用泛型响应结构
// ========================
// 所有接口响应的基础结构，通过泛型参数 T 承载具体业务数据
type BaseResponse<T> {
    ErrCode code        // 错误码
    string message      // 错误描述信息
    T data              // 实际业务数据
}

// ========================
// 用户实体定义
// ========================
// 描述系统中的用户基础信息
type User {
    required string id
    required string name (validate="$ != '' && len($) >= 3")
    string email (validate="email($)")
    int age (json="user_age")
}

// ========================
// 用户列表结构
// ========================
// 用于列表类接口的返回数据
type UserList {
    list<User> users
    int total
}

// ========================
// 创建用户请求结构
// ========================
// 创建用户接口的请求参数定义
type CreateUserRequest {
    required string name (validate="$ != '' && len($) >= 3")
    required string email (validate="email($)")
    required string password (validate="len($) >= 6")
}

// ========================
// 创建用户响应类型
// ========================
// 基于 BaseResponse<User> 的具体响应类型
type CreateUserResponse BaseResponse<User>

// ========================
// 创建用户接口定义
// ========================
// 使用 POST 方法创建新用户
rpc CreateUser (CreateUserRequest) CreateUserResponse {
    method = "POST"
    path = "/user/create"
    contentType = "json"
    connTimeout = "100"
    readTimeout = "300"
    writeTimeout = "300"
    summary = "创建用户"
}

// ========================
// 更新用户请求结构
// ========================
// 支持部分字段更新，未传字段将保持原值
type UpdateUserRequest {
    required string id (path="id", validate="$ != ''")
    string name (validate="$ == '' || len($) >= 3")
    string email (validate="email($)")
    map<string, string> metadata (json="meta_data")
    list<string> tags
    Status status
}

// ========================
// 更新用户响应类型
// ========================
type UpdateUserResponse BaseResponse<User>

// ========================
// 更新用户接口定义
// ========================
// 通过路径参数指定需要更新的用户
rpc UpdateUser (UpdateUserRequest) UpdateUserResponse {
    method = "PUT"
    path = "/user/:id"
    contentType = "json"
    connTimeout = "100"
    readTimeout = "300"
    writeTimeout = "300"
    summary = "更新用户信息"
}

// ========================
// 获取用户列表请求结构
// ========================
// 使用查询参数进行分页与排序控制
type GetUserListRequest {
    int page (query="page")
    int size (query="size")
    string sort (query="sort")
}

// ========================
// 获取用户列表响应类型
// ========================
type GetUserListResponse BaseResponse<UserList>

// ========================
// 获取用户列表接口定义
// ========================
// 返回分页后的用户列表数据
rpc GetUserList (GetUserListRequest) GetUserListResponse {
    method = "GET"
    path = "/users"
    contentType = "json"
    connTimeout = "100"
    readTimeout = "300"
    writeTimeout = "300"
    summary = "获取用户列表"
}

// ========================
// 用户更新事件流请求
// ========================
// 用于订阅指定用户的变更事件
type UserUpdatesRequest {
    required string id (path="id", validate="$ != ''")
}

// ========================
// 获取单个用户响应类型
// ========================
type GetUserResponse BaseResponse<User>

// ========================
// 用户更新 SSE 流接口定义
// ========================
// 通过 SSE 方式持续推送用户更新事件
sse UserUpdates (UserUpdatesRequest) GetUserResponse {
    method = "GET"
    path = "/user/:id/updates"
    contentType = "text/event-stream"
    connTimeout = "100"
    readTimeout = "300"
    writeTimeout = "300"
    summary = "用户更新事件流"
}
```

### 示例说明

该示例体现了以下几个 **gs-http-gen IDL 的核心设计理念**：

1. **统一响应结构**
   通过泛型 `BaseResponse<T>` 抽象所有接口的响应格式，避免重复定义。

2. **字段级校验前置**
   使用 `validate` 注解将输入校验逻辑固化在接口定义层，减少实现侧分散校验。

3. **HTTP 语义显式声明**
   接口的 HTTP 方法、路径、超时配置等均通过注解明确声明，避免隐式约定。

4. **流式与非流式接口统一建模**
   普通 RPC 与 SSE 接口在语法结构上保持一致，仅通过关键字区分。

5. **面向真实业务场景设计**
   示例覆盖创建、更新、查询、列表以及实时推送等常见业务操作，具有直接参考价值。

