// Code generated by gs-http-gen compiler. DO NOT EDIT.

package proto

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/go-spring/stdlib/errutil"
	"github.com/go-spring/stdlib/formutil"
	"github.com/go-spring/stdlib/hashutil"
	"github.com/go-spring/stdlib/httpsvr"
	"github.com/go-spring/stdlib/jsonflow"
)

var _ = strings.Index
var _ = strconv.FormatInt
var _ = base64.StdEncoding
var _ = http.StatusNotFound
var _ = (*httpsvr.Router)(nil)
var _ = formutil.EncodeInt[int]

type PayloadType int32

const (
	PayloadType_MessageDelta PayloadType = 1
	PayloadType_ToolCall     PayloadType = 2
	PayloadType_ImageData    PayloadType = 3
	PayloadType_ErrorInfo    PayloadType = 4
)

var (
	PayloadType_name = map[PayloadType]string{
		1: "MessageDelta",
		2: "ToolCall",
		3: "ImageData",
		4: "ErrorInfo",
	}
	PayloadType_value = map[string]PayloadType{
		"MessageDelta": 1,
		"ToolCall":     2,
		"ImageData":    3,
		"ErrorInfo":    4,
	}
)

// OneOfPayloadType reports whether it's a valid PayloadType.
func OneOfPayloadType(i PayloadType) bool {
	_, ok := PayloadType_name[i]
	return ok
}

// OneOfPayloadTypeAsString reports whether it's a valid PayloadTypeAsString.
func OneOfPayloadTypeAsString(i PayloadTypeAsString) bool {
	_, ok := PayloadType_name[PayloadType(i)]
	return ok
}

// PayloadTypeAsString wraps PayloadType to encode/decode as a JSON string.
type PayloadTypeAsString PayloadType

// MarshalJSON encodes the enum value as its string name.
func (x PayloadTypeAsString) MarshalJSON() ([]byte, error) {
	if s, ok := PayloadType_name[PayloadType(x)]; ok {
		return []byte(fmt.Sprintf("\"%s\"", s)), nil
	}
	return nil, errutil.Explain(nil, "invalid PayloadTypeAsString: %d", x)
}

// UnmarshalJSON decodes the enum value from its string name.
func (x *PayloadTypeAsString) UnmarshalJSON(data []byte) error {
	str := strings.Trim(string(data), "\"")
	if v, ok := PayloadType_value[str]; ok {
		*x = PayloadTypeAsString(v)
		return nil
	}
	return errutil.Explain(nil, "invalid PayloadTypeAsString value: %q", str)
}

// Chat message unit
type Message struct {
	Role    *string `json:"role,omitempty" form:"role"`
	Content *string `json:"content,omitempty" form:"content"`
}

// NewMessage creates a new Message instance
// and initializes fields with default values.
func NewMessage() *Message {
	return &Message{}
}

// DecodeJSON decodes a JSON object into Message using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *Message) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashRole    = 0xa358ec1ff0c833b9 // HashKey("role")
		hashContent = 0x420c75b526b35282 // HashKey("content")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashRole:
			if r.Role, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashContent:
			if r.Content, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}

// Streaming assistant request
type AssistantReq struct {
	AssistantReqBody
}

// NewAssistantReq creates a new AssistantReq instance
// and initializes fields with default values.
func NewAssistantReq() *AssistantReq {
	return &AssistantReq{}
}

// QueryForm encodes query-bound fields into URL-encoded form data.
func (x *AssistantReq) QueryForm() (string, error) {
	return "", nil
}

// Bind extracts path and query parameters from the HTTP request
// and assigns them to the corresponding struct fields.
func (x *AssistantReq) Bind(r *http.Request) error {
	return nil
}

// Validate validates both bound parameters and request body fields.
func (x *AssistantReq) Validate() error {
	if err := x.AssistantReqBody.Validate(); err != nil {
		return errutil.Explain(err, "validate failed on \"AssistantReq\"")
	}
	return nil
}

// AssistantReqBody represents the request body payload,
// excluding path and query parameters.
type AssistantReqBody struct {
	SessionId *string    `json:"sessionId,omitempty" form:"sessionId"`
	UserId    *string    `json:"userId,omitempty" form:"userId"`
	Messages  []*Message `json:"messages,omitempty" form:"messages"`
}

// NewAssistantReqBody creates a new AssistantReqBody instance
// and initializes fields with default values.
func NewAssistantReqBody() *AssistantReqBody {
	return &AssistantReqBody{}
}

// DecodeJSON decodes a JSON object into AssistantReqBody using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *AssistantReqBody) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashSessionId = 0x154f245dce3e85fa // HashKey("sessionId")
		hashUserId    = 0xf7d13faa74e2475f // HashKey("userId")
		hashMessages  = 0xec1bef4f4de4355  // HashKey("messages")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashSessionId:
			if r.SessionId, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashUserId:
			if r.UserId, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashMessages:
			if r.Messages, err = jsonflow.DecodeArray(jsonflow.DecodeObject(NewMessage))(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}

// Validate checks field values using generated validation expressions.
func (x *AssistantReqBody) Validate() error {
	return nil
}

// Incremental message payload
type MessageDelta struct {
	Content *string `json:"content,omitempty" form:"content"`
	IsFinal *bool   `json:"isFinal,omitempty" form:"isFinal"`
}

// NewMessageDelta creates a new MessageDelta instance
// and initializes fields with default values.
func NewMessageDelta() *MessageDelta {
	return &MessageDelta{}
}

// DecodeJSON decodes a JSON object into MessageDelta using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *MessageDelta) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashContent = 0x420c75b526b35282 // HashKey("content")
		hashIsFinal = 0xce237000e53a0967 // HashKey("isFinal")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashContent:
			if r.Content, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashIsFinal:
			if r.IsFinal, err = jsonflow.DecodeBoolPtr(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}

// Tool call payload
type ToolCall struct {
	Name      *string           `json:"name,omitempty" form:"name"`
	Arguments map[string]string `json:"arguments,omitempty" form:"arguments"`
}

// NewToolCall creates a new ToolCall instance
// and initializes fields with default values.
func NewToolCall() *ToolCall {
	return &ToolCall{}
}

// DecodeJSON decodes a JSON object into ToolCall using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *ToolCall) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashName      = 0xc4bcadba8e631b86 // HashKey("name")
		hashArguments = 0xe42e0c2563a2219f // HashKey("arguments")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashName:
			if r.Name, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashArguments:
			if r.Arguments, err = jsonflow.DecodeMap(jsonflow.DecodeString, jsonflow.DecodeString)(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}

// Image payload
type ImageData struct {
	Mime *string `json:"mime,omitempty" form:"mime"`
	Data []byte  `json:"data,omitempty" form:"data"`
}

// NewImageData creates a new ImageData instance
// and initializes fields with default values.
func NewImageData() *ImageData {
	return &ImageData{}
}

// DecodeJSON decodes a JSON object into ImageData using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *ImageData) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashMime = 0xda5205a2a792ac3d // HashKey("mime")
		hashData = 0x855b556730a34a05 // HashKey("data")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashMime:
			if r.Mime, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashData:
			if r.Data, err = jsonflow.DecodeBytes(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}

// Error payload
type ErrorInfo struct {
	Code    *ErrCode `json:"code,omitempty" form:"code"`
	Message *string  `json:"message,omitempty" form:"message"`
}

// NewErrorInfo creates a new ErrorInfo instance
// and initializes fields with default values.
func NewErrorInfo() *ErrorInfo {
	return &ErrorInfo{}
}

// DecodeJSON decodes a JSON object into ErrorInfo using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *ErrorInfo) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashCode    = 0xbb51791194b4414  // HashKey("code")
		hashMessage = 0x546401b5d2a8d2a4 // HashKey("message")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashCode:
			if r.Code, err = jsonflow.DecodeIntPtr[ErrCode](d); err != nil {
				return err
			}
		case hashMessage:
			if r.Message, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}

// Union payload for SSE events
type Payload struct {
	FieldType    PayloadTypeAsString `json:"FieldType" form:"FieldType" validate:"required"`
	MessageDelta *MessageDelta       `json:"MessageDelta,omitempty" form:"MessageDelta"`
	ToolCall     *ToolCall           `json:"ToolCall,omitempty" form:"ToolCall"`
	ImageData    *ImageData          `json:"ImageData,omitempty" form:"ImageData"`
	ErrorInfo    *ErrorInfo          `json:"ErrorInfo,omitempty" form:"ErrorInfo"`
}

// NewPayload creates a new Payload instance
// and initializes fields with default values.
func NewPayload() *Payload {
	return &Payload{}
}

// DecodeJSON decodes a JSON object into Payload using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *Payload) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashFieldType    = 0x924fb655ccf9c75f // HashKey("FieldType")
		hashMessageDelta = 0x28f9a6652f1ce6d2 // HashKey("MessageDelta")
		hashToolCall     = 0x7612e8c3a2f00937 // HashKey("ToolCall")
		hashImageData    = 0xee537da77a0db6a  // HashKey("ImageData")
		hashErrorInfo    = 0x78d5dfce1dd7c7a9 // HashKey("ErrorInfo")
	)

	var (
		hasFieldType bool
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashFieldType:
			hasFieldType = true
			if r.FieldType, err = jsonflow.DecodeAny[PayloadTypeAsString](d); err != nil {
				return err
			}
		case hashMessageDelta:
			if r.MessageDelta, err = jsonflow.DecodeObject(NewMessageDelta)(d); err != nil {
				return err
			}
		case hashToolCall:
			if r.ToolCall, err = jsonflow.DecodeObject(NewToolCall)(d); err != nil {
				return err
			}
		case hashImageData:
			if r.ImageData, err = jsonflow.DecodeObject(NewImageData)(d); err != nil {
				return err
			}
		case hashErrorInfo:
			if r.ErrorInfo, err = jsonflow.DecodeObject(NewErrorInfo)(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}

	if !hasFieldType {
		return errutil.Explain(err, "missing required field \"FieldType\"")
	}
	return
}

// Single Server-Sent Event
type AssistantEvent struct {
	EventId *string  `json:"eventId,omitempty" form:"eventId"`
	Payload *Payload `json:"payload,omitempty" form:"payload"`
}

// NewAssistantEvent creates a new AssistantEvent instance
// and initializes fields with default values.
func NewAssistantEvent() *AssistantEvent {
	return &AssistantEvent{}
}

// DecodeJSON decodes a JSON object into AssistantEvent using a hash-based
// field dispatch mechanism for high-performance parsing.
func (r *AssistantEvent) DecodeJSON(d jsonflow.Decoder) (err error) {
	const (
		hashEventId = 0xebce335bb0562572 // HashKey("eventId")
		hashPayload = 0xcfb8a9d063b5e9e5 // HashKey("payload")
	)

	if err = jsonflow.DecodeObjectBegin(d); err != nil {
		return err
	}

	for {
		if d.PeekKind() == '}' {
			break
		}

		var key string
		key, err = jsonflow.DecodeString(d)
		if err != nil {
			return err
		}

		switch hashutil.FNV1a64(key) {
		case hashEventId:
			if r.EventId, err = jsonflow.DecodeStringPtr(d); err != nil {
				return err
			}
		case hashPayload:
			if r.Payload, err = jsonflow.DecodeObject(NewPayload)(d); err != nil {
				return err
			}
		default:
			if err = d.SkipValue(); err != nil {
				return err
			}
		}
	}

	if err = jsonflow.DecodeObjectEnd(d); err != nil {
		return err
	}
	return
}
